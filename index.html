<!DOCTYPE html>

<html lang="en">
<head><script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>StatLation</title>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,400;0,500;0,600;0,700;1,400&amp;family=Open+Sans:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.5/jstat.min.js"></script>
<style>
    :root {
      --primary-color: #6366f1;
      --primary-light: #818cf8;
      --primary-dark: #4f46e5;
      --secondary-color: #ec4899;
      --secondary-light: #f472b6;
      --secondary-dark: #db2777;
      --background-color: #f8fafc;
      --card-color: #ffffff;
      --text-primary: #1e293b;
      --text-secondary: #475569;
      --text-tertiary: #64748b;
      --border-color: #e2e8f0;
      --success-color: #22c55e;
      --warning-color: #f59e0b;
      --error-color: #ef4444;
      --info-color: #3b82f6;
      --panel-color: #f1f5f9;
      --shadow-color: rgba(0, 0, 0, 0.1);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Open Sans', sans-serif;
      line-height: 1.6;
      color: var(--text-primary);
      background-color: var(--background-color);
      padding: 0;
      margin: 0;
    }

    h1, h2, h3, h4, h5, h6 {
      font-family: 'Bitter', serif;
      margin-bottom: 0.75rem;
      color: var(--primary-dark);
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
    }

    h2 {
      font-size: 1.8rem;
      font-weight: 600;
      color: var(--primary-color);
    }

    h3 {
      font-size: 1.4rem;
      font-weight: 600;
    }

    p {
      margin-bottom: 1rem;
    }

    /* Header */
    .header {
  background: linear-gradient(to bottom, #D0D6E0, #BFC9DC);
  text-align: center;
  padding: 3rem 1rem 2rem 1rem;
}

    .subtitle {
      font-family: 'Open Sans', sans-serif;
      font-weight: 300;
      font-size: 1.1rem;
      opacity: 0.9;
    }

    /* Main container */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    /* Cards */
    .card {
      background-color: var(--card-color);
      border-radius: 8px;
      box-shadow: 0 2px 10px var(--shadow-color);
      padding: 1.5rem;
      margin-bottom: 2rem;
      transition: all 0.3s ease;
    }

    .card:hover {
      box-shadow: 0 4px 15px var(--shadow-color);
    }

    /* Sections */
    .section {
      padding: 1.5rem 0;
      border-bottom: 1px solid var(--border-color);
    }

    .section:last-child {
      border-bottom: none;
    }

    .section-title {
      display: flex;
      align-items: center;
      margin-bottom: 1.25rem;
    }

    .section-title .number {
      background-color: var(--primary-color);
      color: white;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 0.75rem;
      font-weight: 600;
      font-size: 0.9rem;
    }

    /* Form Elements */
    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    input[type="text"],
    input[type="password"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-family: 'Open Sans', sans-serif;
      font-size: 1rem;
      color: var(--text-primary);
      background-color: white;
      transition: border-color 0.3s;
      margin-bottom: 1rem;
    }

    input[type="text"]:focus,
    input[type="password"]:focus,
    input[type="number"]:focus,
    select:focus,
    textarea:focus {
      border-color: var(--primary-color);
      outline: none;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .input-group {
      margin-bottom: 1.25rem;
    }

    .help-text {
      font-size: 0.875rem;
      color: var(--text-tertiary);
      margin-top: -0.5rem;
      margin-bottom: 1rem;
    }

    /* Buttons */
    .btn {
      display: inline-block;
      padding: 0.75rem 1.5rem;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 4px;
      font-family: 'Open Sans', sans-serif;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-right: 0.75rem;
      margin-bottom: 0.75rem;
    }

    .btn:hover {
      background-color: var(--primary-dark);
      box-shadow: 0 2px 5px var(--shadow-color);
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn:disabled {
      background-color: var(--text-tertiary);
      cursor: not-allowed;
    }

    .btn-secondary {
      background-color: var(--secondary-color);
    }

    .btn-secondary:hover {
      background-color: var(--secondary-dark);
    }

    .btn-outline {
      background-color: transparent;
      border: 1px solid var(--primary-color);
      color: var(--primary-color);
    }

    .btn-outline:hover {
      background-color: var(--primary-color);
      color: white;
    }

    .btn-large {
      padding: 1rem 2rem;
      font-size: 1rem;
    }

    /* Progress */
    .progress-container {
      margin: 1.5rem 0;
    }

    .progress {
      height: 8px;
      background-color: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--primary-color), var(--primary-light));
      width: 0%;
      transition: width 0.4s ease;
    }

    .progress-label {
      display: flex;
      justify-content: space-between;
      margin-top: 0.5rem;
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 1.5rem;
      font-size: 0.9rem;
    }

    thead th {
      background-color: var(--primary-color);
      color: white;
      padding: 0.75rem;
      text-align: left;
      font-weight: 600;
    }

    tbody tr:nth-child(even) {
      background-color: rgba(0, 0, 0, 0.02);
    }

    tbody td {
      padding: 0.75rem;
      border-bottom: 1px solid var(--border-color);
    }

    tbody tr:hover {
      background-color: rgba(99, 102, 241, 0.05);
    }

    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 1.5rem;
    }

    .tab {
      padding: 0.75rem 1.5rem;
      cursor: pointer;
      font-weight: 600;
      color: var(--text-secondary);
      border-bottom: 3px solid transparent;
      transition: all 0.3s;
    }

    .tab.active {
      color: var(--primary-color);
      border-bottom-color: var(--primary-color);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Charts */
    .chart-container {
      width: 100%;
      height: 400px;
      position: relative;
      margin: 2rem 0;
      background-color: white;
      border-radius: 8px;
      padding: 1rem;
      box-shadow: 0 1px 3px var(--shadow-color);
    }

    /* Cards Grid */
    .cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-top: 1.5rem;
    }

    .stat-card {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 5px var(--shadow-color);
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      border-top: 3px solid var(--primary-color);
    }

    .stat-card .title {
      font-size: 0.875rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    .stat-card .value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 0.5rem;
    }

    .stat-card .description {
      font-size: 0.875rem;
      color: var(--text-tertiary);
      margin-top: auto;
    }

    /* Toggle */
    .toggle-container {
      display: flex;
      align-items: center;
      margin-bottom: 1rem;
    }

    .toggle-label {
      margin-right: 0.75rem;
      font-weight: 600;
    }

    .toggle {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 26px;
    }

    .toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: var(--primary-color);
    }

    input:checked + .toggle-slider:before {
      transform: translateX(24px);
    }

    /* Console */
    .console {
      background-color: #1e293b;
      color: #e2e8f0;
      padding: 1rem;
      border-radius: 4px;
      font-family: "Consolas", "Monaco", monospace;
      height: 200px;
      overflow-y: auto;
      margin-bottom: 1.5rem;
    }

    .console .log-entry {
      margin-bottom: 0.5rem;
      font-size: 0.875rem;
      line-height: 1.4;
    }

    .console .timestamp {
      color: #a5f3fc;
      margin-right: 0.5rem;
    }

    .console .info {
      color: #93c5fd;
    }

    .console .warning {
      color: #fcd34d;
    }

    .console .error {
      color: #fca5a5;
    }

    /* Alerts */
    .alert {
      padding: 1rem;
      border-radius: 4px;
      margin-bottom: 1rem;
    }

    .alert-success {
      background-color: rgba(34, 197, 94, 0.1);
      border-left: 4px solid var(--success-color);
      color: var(--success-color);
    }

    .alert-warning {
      background-color: rgba(245, 158, 11, 0.1);
      border-left: 4px solid var(--warning-color);
      color: var(--warning-color);
    }

    .alert-error {
      background-color: rgba(239, 68, 68, 0.1);
      border-left: 4px solid var(--error-color);
      color: var(--error-color);
    }

    .alert-info {
      background-color: rgba(59, 130, 246, 0.1);
      border-left: 4px solid var(--info-color);
      color: var(--info-color);
    }

    /* Modal */
    .modal-backdrop {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1000;
    }

    .modal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      z-index: 1001;
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-header {
      padding: 1.25rem 1.5rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .modal-title {
      font-weight: 600;
      font-size: 1.25rem;
      margin: 0;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-tertiary);
    }

    .modal-body {
      padding: 1.5rem;
    }

    .modal-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border-color);
      text-align: right;
    }

    /* Variable Selection */
    .variable-select-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .variable-list {
      background-color: white;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      height: 200px;
      overflow-y: auto;
      padding: 0.5rem;
    }

    .variable-item {
      padding: 0.75rem;
      cursor: pointer;
      border-radius: 4px;
      margin-bottom: 0.25rem;
      transition: all 0.2s;
      border-left: 3px solid transparent;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .variable-item:hover {
      background-color: rgba(99, 102, 241, 0.1);
      border-left-color: var(--primary-light);
    }

    .variable-item.selected {
      background-color: rgba(99, 102, 241, 0.2);
      border-left-color: var(--primary-color);
      font-weight: 600;
    }

    .variable-type {
      font-size: 0.75rem;
      padding: 0.2rem 0.5rem;
      border-radius: 10px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .type-numerical {
      background-color: #dbeafe;
      color: #1d4ed8;
    }

    .type-categorical {
      background-color: #fef3c7;
      color: #92400e;
    }

    .type-date {
      background-color: #dcfce7;
      color: #166534;
    }

    .type-text {
      background-color: #f3e8ff;
      color: #7e22ce;
    }

    /* Collapsible section */
    .collapsible {
      background-color: var(--panel-color);
      cursor: pointer;
      padding: 1rem;
      width: 100%;
      border: none;
      text-align: left;
      outline: none;
      font-size: 1rem;
      font-weight: 600;
      border-radius: 4px;
      transition: 0.4s;
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .collapsible:after {
      content: '+';
      font-size: 1.2rem;
      font-weight: bold;
      float: right;
      margin-left: 1rem;
    }

    .active:after {
      content: '-';
    }

    .collapsible-content {
      padding: 0 1rem;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.2s ease-out;
      background-color: white;
      border-radius: 0 0 4px 4px;
    }

    /* Checkboxes and Radio buttons */
    .checkbox-container, .radio-container {
      display: flex;
      align-items: center;
      margin-bottom: 0.75rem;
    }

    input[type="checkbox"], input[type="radio"] {
      margin-right: 0.5rem;
    }

    /* Explanation panels */
    .explanation-panel {
      background-color: rgba(99, 102, 241, 0.05);
      border-left: 4px solid var(--primary-color);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 4px 4px 0;
    }

    .explanation-panel h4 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      color: var(--primary-color);
    }

    /* APA Style Results */
    .apa-results {
      font-family: 'Bitter', serif;
      padding: 1.5rem;
      background-color: white;
      border-radius: 4px;
      box-shadow: 0 1px 3px var(--shadow-color);
      line-height: 1.8;
    }

    /* Variable Selection Box */
    .variable-selection-box {
      background-color: white;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 1px 3px var(--shadow-color);
    }

    .variable-selection-box h3 {
      margin-top: 0;
      margin-bottom: 1rem;
      color: var(--primary-color);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.5rem;
    }

    .variable-columns {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
    }

    @media (max-width: 768px) {
      .variable-columns {
        grid-template-columns: 1fr;
      }
    }

    .variable-section {
      margin-bottom: 1.5rem;
    }

    .variable-section h4 {
      margin-bottom: 0.5rem;
      color: var(--text-secondary);
      font-size: 1rem;
    }

    .variables-container {
      max-height: 250px;
      overflow-y: auto;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--panel-color);
    }

    /* Start Analysis Button */
    .start-analysis-btn {
      margin-top: 1.5rem;
      text-align: center;
    }

    /* Results Visualization */
    .results-visualization {
      margin-top: 2rem;
    }

    .visualization-panel {
      padding: 1rem;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 1px 3px var(--shadow-color);
      margin-bottom: 1.5rem;
    }

    .visualization-panel h3 {
      color: var(--primary-color);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 0.5rem;
      margin-bottom: 1rem;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .container {
        padding: 1rem;
      }

      h1 {
        font-size: 2rem;
      }

      .variable-select-container {
        grid-template-columns: 1fr;
      }

      .chart-container {
        height: 300px;
      }

      .cards-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Footer */
    .footer {
      background-color: var(--primary-dark);
      color: white;
      text-align: center;
      padding: 1.5rem 0;
      margin-top: 3rem;
    }

    .footer p {
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
      opacity: 0.9;
    }

    /* Loading spinner */
    .spinner {
      display: inline-block;
      width: 50px;
      height: 50px;
      border: 3px solid rgba(99, 102, 241, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .spinner-container {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      z-index: 999;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    .spinner-text {
      margin-top: 1rem;
      font-weight: 600;
      color: var(--primary-color);
    }

    /* Test specific options */
    .test-options {
      display: none;
      margin-top: 1rem;
      padding: 1rem;
      background-color: var(--panel-color);
      border-radius: 4px;
    }

    /* Steps navigation */
    .steps-nav {
      display: flex;
      justify-content: center;
      margin: 2rem 0;
    }

    .step-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0 1rem;
      position: relative;
      flex: 1;
      max-width: 180px;
    }

    .step-item:not(:last-child):after {
      content: '';
      position: absolute;
      top: 20px;
      right: -50%;
      width: 100%;
      height: 2px;
      background-color: var(--border-color);
      z-index: 1;
    }

    .step-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: var(--panel-color);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      margin-bottom: 0.5rem;
      border: 2px solid var(--border-color);
      position: relative;
      z-index: 2;
    }

    .step-item.active .step-icon {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }

    .step-item.completed .step-icon {
      background-color: var(--success-color);
      color: white;
      border-color: var(--success-color);
    }

    .step-item.completed:after {
      background-color: var(--success-color);
    }

    .step-label {
      font-size: 0.85rem;
      font-weight: 500;
      text-align: center;
      color: var(--text-secondary);
    }

    .step-item.active .step-label {
      color: var(--primary-color);
      font-weight: 600;
    }

    .step-item.completed .step-label {
      color: var(--success-color);
    }
  </style>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700;800&amp;display=swap" rel="stylesheet"/>
<style>
.header {
  background: linear-gradient(to bottom, #D0D6E0, #BFC9DC);
  text-align: center;
  padding: 3rem 1rem 2rem 1rem;
}

.title {
  font-family: 'Poppins', sans-serif;
  font-size: 76px;
  font-weight: 800;
  color: #FFFFFF;
  text-align: center;
  letter-spacing: -0.3px;
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
  margin-bottom: 0.5rem;
}

.subheading {
  font-family: 'Poppins', sans-serif;
  font-size: 27px;
  font-weight: 500;
  color: #DADADA;
  text-align: center;
  max-width: 80%;
  margin: 0 auto;
  letter-spacing: 0.3px;
}
</style>
<style>
.footer {
  background-color: #5C5CFF;
  color: #F1F1F1;
  text-align: center;
  padding: 20px 0;
  font-size: 17px;
}
.footer p {
  margin: 4px 0;
}
</style>
<style>
.title {
  font-family: 'Poppins', sans-serif;
  font-size: 76px;
  font-weight: 800;
  background: linear-gradient(90deg, #5C5CFF, #00CFFD);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-align: center;
  letter-spacing: -0.3px;
  margin-bottom: 0.5rem;
  transition: transform 0.3s ease, text-shadow 0.3s ease;
  animation: fadeInUp 0.8s ease-out both;
}

.title:hover {
  transform: scale(1.03);
  text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.15);
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
</style>
<style>
.file-info-card {
  padding: 1rem;
  background-color: #f9fafb;
  border: 1px solid #e2e8f0;
  border-radius: 6px;
  font-size: 0.95rem;
  color: #334155;
  box-shadow: 0 1px 4px rgba(0,0,0,0.05);
  transition: all 0.3s ease;
}
.progress {
  height: 8px;
  background-color: #e2e8f0;
  border-radius: 4px;
  overflow: hidden;
  margin-top: 1rem;
}
.progress-bar {
  height: 100%;
  width: 0%;
  background: linear-gradient(to right, #5C5CFF, #00CFFD);
  transition: width 0.4s ease;
}
.upload-area.dragover {
  animation: pulse 0.6s infinite alternate;
}
@keyframes pulse {
  from { background-color: #e0e7ff; }
  to { background-color: #dbeafe; }
}
</style>
<style>
.variable-item {
  background-color: #f8fafc;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 1rem;
  margin-bottom: 0.5rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.3s ease;
  animation: fadeInScale 0.3s ease-out;
  cursor: pointer;
}
.variable-item:hover {
  background-color: #eef2ff;
  transform: scale(1.02);
  box-shadow: 0 2px 8px rgba(99, 102, 241, 0.1);
}
.variable-type {
  font-size: 0.75rem;
  padding: 0.3rem 0.6rem;
  border-radius: 20px;
  font-weight: 600;
  text-transform: uppercase;
  transition: background-color 0.3s ease;
}
.variable-type.type-numerical {
  background-color: #dbeafe;
  color: #1d4ed8;
}
.variable-type.type-categorical {
  background-color: #fef3c7;
  color: #92400e;
}
@keyframes fadeInScale {
  0% { transform: scale(0.95); opacity: 0; }
  100% { transform: scale(1); opacity: 1; }
}
.variable-item.selected {
  border: 2px solid var(--primary-color);
  background-color: #e0e7ff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-sparklines/2.1.2/jquery.sparkline.min.js"></script><style>
  #variable-summary-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
  }
  
  #variable-summary-table th {
    background-color: #6366f1;
    color: white;
    padding: 0.75rem;
    text-align: left;
    position: sticky;
    top: 0;
  }
  
  #variable-summary-table td {
    padding: 0.75rem;
    border-bottom: 1px solid #e2e8f0;
  }
  
  #variable-summary-table tbody tr:hover {
    background-color: #eef2ff;
  }
  
  #variable-summary-table-container {
    max-height: 400px;
    overflow-y: auto;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    margin-top: 1rem;
  }
  
  /* Role-based coloring */
  #variable-summary-table td:nth-child(2) {
    font-weight: 600;
  }
</style></head>
<body>
<div class="header">
<div class="container">
<h1 class="title">StatLation</h1>
<p class="subtitle">Advanced Statistical Analysis Tool For Empirical Translation Data</p>
</div>
</div>
<div class="container">
<!-- Steps Navigation -->
<div class="steps-nav">
<div class="step-item active" id="step-1">
<div class="step-icon">1</div>
<div class="step-label">Setup</div>
</div>
<div class="step-item" id="step-2">
<div class="step-icon">2</div>
<div class="step-label">Upload Data</div>
</div>
<div class="step-item" id="step-3">
<div class="step-icon">3</div>
<div class="step-label">Select Variables</div>
</div>
<div class="step-item" id="step-4">
<div class="step-icon">4</div>
<div class="step-label">Analysis</div>
</div>
<div class="step-item" id="step-5">
<div class="step-icon">5</div>
<div class="step-label">Results</div>
</div>
</div>
<!-- API Key Section -->
<div class="card" id="api-key-card">
<div class="section-title">
<div class="number">1</div>
<h2>OpenAI API Configuration</h2>
</div>
<div class="section">
<p>Enter your OpenAI API key to enable AI-assisted analysis of your data.</p>
<div class="input-group">
<label for="api-key">OpenAI API Key:</label>
<input id="api-key" placeholder="sk-..." type="password"/>
<p class="help-text">Your API key is securely stored in your browser and never transmitted to our servers.</p>
</div>
<button class="btn" id="save-api-key">Save API Key</button>
<div id="api-status"></div>
</div>
</div>
<!-- Updated Upload Data File Section with Drag & Drop -->
<div class="card" id="data-upload-card">
<div class="section-title">
<div class="number">2</div>
<h2>Upload Data File</h2>
</div>
<div class="section">
<p>Upload your Excel or CSV file.</p>
<div class="upload-area" id="upload-area">
<input accept=".xlsx,.xls,.csv" hidden="" id="file-upload" type="file"/>
<div id="drag-drop-zone">
<p><strong>Drag &amp; Drop</strong> your file here or <label class="upload-browse" for="file-upload">Browse</label></p>
<p class="help-text">Accepted formats: Excel (.xlsx, .xls) or CSV (.csv)</p>
</div>
</div>
<button class="btn" id="upload-btn">Upload Data</button>
<div id="file-status"></div>
<div class="progress">
<div class="progress-bar" id="upload-progress-bar"></div>
</div>
<div class="file-info-card" id="file-info" style="display:none; margin-top:1rem;"></div>
</div>
<!-- Data Preview -->
<div class="section" id="data-preview-section" style="display: none;">
<h3>Data Preview</h3>
<div id="data-preview"></div>
</div>
</div>
<style>
.upload-area {
  border: 2px dashed var(--primary-color);
  border-radius: 8px;
  padding: 2rem;
  text-align: center;
  background-color: var(--panel-color);
  cursor: pointer;
  transition: border-color 0.3s, background-color 0.3s;
  margin-bottom: 1rem;
}
.upload-area:hover {
  background-color: #eef2ff;
  border-color: var(--primary-dark);
}
.upload-browse {
  color: var(--primary-color);
  text-decoration: underline;
  cursor: pointer;
}
.upload-area.dragover {
  background-color: #e0e7ff;
  border-color: var(--primary-dark);
}
</style>
<script>
const dragDropZone = document.getElementById('upload-area');
const fileInput = document.getElementById('file-upload');

['dragenter', 'dragover'].forEach(event => {
  dragDropZone.addEventListener(event, e => {
    e.preventDefault();
    e.stopPropagation();
    dragDropZone.classList.add('dragover');
  });
});

['dragleave', 'drop'].forEach(event => {
  dragDropZone.addEventListener(event, e => {
    e.preventDefault();
    e.stopPropagation();
    dragDropZone.classList.remove('dragover');
  });
});

dragDropZone.addEventListener('drop', e => {
  const files = e.dataTransfer.files;
  if (files.length > 0) {
    fileInput.files = files;
    document.getElementById('upload-btn').click();
  }
});
</script>
<!-- Data Upload Section -->
<!-- Variable List Section -->
<div class="card" id="variable-list-card" style="display: none;">
<div class="card" id="variable-summary-card">
<div class="section-title">
<div class="number">3.1</div>
<h2>Variable Summary Table</h2>
</div>
<div class="section"><div class="explanation-panel" style="margin-bottom: 1rem;"><h4>Dataset Overview</h4><div id="data-summary-stats"><p>Analyzing <span id="var-count">0</span> variables (<span id="numerical-count">0</span> numerical, <span id="categorical-count">0</span> categorical) from <span id="row-count">0</span> observations.</p></div></div>
<p>This table summarizes the variables in your dataset, categorized by their role in statistical modeling.</p>
<div id="variable-summary-table-container">
<table id="variable-summary-table">
<thead>
<tr>
<th>Variable Name</th>
<th>Role</th>
<th>Type</th>
<th>Notes</th>
</tr>
</thead>
<tbody id="variable-summary-body">
</tbody>
</table>
</div>
<button class="btn btn-outline" onclick="exportVariableSummary()" style="margin-top: 1rem;">Export Variable Summary</button><script>
function exportVariableSummary() {
  let csv = 'Variable Name,Role,Type,Notes\n';
  
  columns.forEach(col => {
    const type = inferColumnType(col);
    const values = dataTable.map(row => row[col]).filter(val => val !== null && val !== undefined);
    const uniqueCount = new Set(values).size;
    const missingCount = dataTable.length - values.length;
    const missingPercentage = ((missingCount / dataTable.length) * 100).toFixed(1);
    
    let role = "Independent";
    let varType = type === "Numerical" ? "Continuous" : "Categorical";
    let notes = "";
    
    // Same logic as in buildVariableSummaryTable
    if (col.toLowerCase().includes("id") || col.toLowerCase().includes("participant")) {
      role = "Random/Blocking";
      varType = "Nominal";
      notes = "Identifier or subject-level grouping";
    } else if (col.toLowerCase().includes("score") || col.toLowerCase().includes("quality")) {
      role = "Dependent";
      varType = "Continuous";
      notes = "Scoring metric or rating";
    } else if (col.toLowerCase().includes("error") || col.toLowerCase().includes("count")) {
      role = "Dependent";
      varType = "Count";
      notes = "Discrete count of events or errors";
    } else if (type === "Numerical" && uniqueCount > 5) {
      role = "Dependent";
      notes = "High variability continuous measure";
    }
    
    // Escape any commas in the notes
    const escapedNotes = notes.replace(/,/g, ";");
    
    csv += `${col},${role},${varType},${escapedNotes}\n`;
  });
  
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'variable_summary.csv';
  a.click();
  URL.revokeObjectURL(url);
}
</script></div>
</div>
<script>
function buildVariableSummaryTable() {
  const container = document.getElementById("variable-summary-body");
  if (!container) return;
  container.innerHTML = "";

  columns.forEach(col => {
    const type = inferColumnType(col);
    const values = dataTable.map(row => row[col]).filter(val => val !== null && val !== undefined);
    const uniqueCount = new Set(values).size;
    const missingCount = dataTable.length - values.length;
    const missingPercentage = ((missingCount / dataTable.length) * 100).toFixed(1);
    const firstRow = values[0];
    
    let role = "Independent";
    variableRoles[col] = role;
    let varType = type === "Numerical" ? "Continuous" : "Categorical";
    let notes = "";
    
    // Enhanced role and type detection
    if (col.toLowerCase().includes("id") || col.toLowerCase().includes("participant")) {
      role = "Random/Blocking";
      varType = "Nominal";
      notes = "Identifier or subject-level grouping. Used for subject-specific analysis.";
    } else if (col.toLowerCase().includes("score") || col.toLowerCase().includes("quality") || col.toLowerCase().includes("accuracy")) {
      role = "Dependent";
      varType = "Continuous";
      notes = "Scoring metric or rating. Primary outcome variable for quality assessment.";
    } else if (col.toLowerCase().includes("error") || col.toLowerCase().includes("count")) {
      role = "Dependent";
      varType = "Count";
      notes = "Discrete count of events or errors. Suitable for error analysis.";
    } else if (col.toLowerCase().includes("time") || col.toLowerCase().includes("duration")) {
      role = "Dependent";
      varType = "Continuous";
      notes = "Time measurement. Useful for process or efficiency analysis.";
    } else if (col.toLowerCase().includes("group") || col.toLowerCase().includes("type") || col.toLowerCase().includes("category")) {
      role = "Independent";
      varType = "Categorical";
      notes = "Grouping variable. Used for between-group comparisons.";
    } else if (col.toLowerCase().includes("experience") || col.toLowerCase().includes("years")) {
      role = "Independent/Covariate";
      varType = "Continuous";
      notes = "Experience measurement. Potential predictor or control variable.";
    } else if (type === "Numerical" && uniqueCount > 5) {
      role = "Likely Dependent";
      notes = "High variability continuous measure. Possibly an outcome variable.";
    } else if (type === "Categorical" && uniqueCount <= 5) {
      notes = "Limited categories. Suitable for grouping or factorial design.";
    } else if (type === "Categorical" && uniqueCount > 10) {
      notes = "Many unique values. May need recoding for effective analysis.";
    } else {
      notes = "General variable. Review context to determine appropriate role.";
    }
    
    // Add data quality information
    if (missingCount > 0) {
      notes += ` Contains ${missingPercentage}% missing values.`;
    }
    
    // Add descriptive statistics for numerical variables
    if (type === "Numerical" && values.length > 0) {
      try {
        const numValues = values.map(v => parseFloat(v)).filter(v => !isNaN(v));
        if (numValues.length > 0) {
          const mean = calculateMean(numValues).toFixed(2);
          const min = Math.min(...numValues).toFixed(2);
          const max = Math.max(...numValues).toFixed(2);
          notes += ` Range: [${min}-${max}], Mean: ${mean}.`;
        }
      } catch (e) {
        // Skip if error in calculating stats
      }
    }

    container.innerHTML += `
      <tr>
        <td>${col}</td>
        <td>${role}</td>
        <td>${varType}</td>
        <td>${notes}</td>
      </tr>
    `;
  });
  
  // Call the function to update summary statistics
  updateDataSummary();
}

function updateDataSummary() {
  if (!dataTable || !columns) return;
  
  document.getElementById('var-count').textContent = columns.length;
  document.getElementById('row-count').textContent = dataTable.length;
  document.getElementById('numerical-count').textContent = columns.filter(col => inferColumnType(col) === 'Numerical').length;
  document.getElementById('categorical-count').textContent = columns.filter(col => inferColumnType(col) === 'Categorical').length;
}
</script>
<div class="section-title">
<div class="number">3</div>
<h2>Available Variables</h2>
</div>
<div class="section">
<p>Below is a list of all variables found in your dataset. You'll use these variables in your statistical analysis.</p>
<div class="variable-selection-box">
<h3>Dataset Variables</h3>
<div class="variable-columns">
<div class="variable-section">
<h4>Numerical Variables</h4>
<div style="margin-bottom: 1rem;">
<input id="variable-search" placeholder="ðŸ” Search variables..." style="width: 100%; padding: 0.75rem; border: 1px solid #cbd5e1; border-radius: 6px; font-size: 1rem;" type="text"/>
</div>
<div class="variables-container" id="numerical-variables">
<!-- Numerical variables will be listed here -->
</div>
</div>
<div class="variable-section">
<h4>Categorical Variables</h4>
<div class="variables-container" id="categorical-variables">
<!-- Categorical variables will be listed here -->
</div>
</div>
</div>
</div>
<button class="btn btn-large" id="continue-to-test">Continue to Select Statistical Test</button>

<script>
function buildVariableSummaryTable() {
  const container = document.getElementById("variable-summary-body");
  if (!container) return;
  container.innerHTML = "";

  columns.forEach(col => {
    const type = inferColumnType(col);
    const values = dataTable.map(row => row[col]).filter(val => val !== null && val !== undefined);
    const uniqueCount = new Set(values).size;
    const firstRow = values[0];
    let role = "Independent";
    variableRoles[col] = role;
    let varType = type === "Numerical" ? "Continuous" : "Categorical";
    let notes = "";

    if (col.toLowerCase().includes("id") || col.toLowerCase().includes("participant")) {
      role = "Random/Blocking";
      varType = "Nominal";
      notes = "Identifier or subject-level grouping";
    } else if (col.toLowerCase().includes("score")) {
      role = "Dependent";
      varType = "Continuous";
      notes = "Scoring metric or rating";
    } else if (col.toLowerCase().includes("error") || col.toLowerCase().includes("count")) {
      role = "Dependent";
      varType = "Count";
      notes = "Discrete count of events or errors";
    } else if (type === "Numerical" && uniqueCount > 5) {
      role = "Dependent";
    }

    container.innerHTML += `
      <tr>
        <td>${col}</td>
        <td>${role}</td>
        <td>${varType}</td>
        <td>${notes}</td>
      </tr>
    `;
  });
}
</script>
<script>setTimeout(buildVariableSummaryTable, 1000);</script>
</div>
</div>
<div class="card" id="ai-pipeline-card" style="margin-top: 2rem;">
<div class="section-title">
<div class="number">â˜…</div>
<h2>Hypothesis &amp; Analysis Suggestions</h2>
</div>
<div class="section">
<p>The system scans your dataset and recommends the most appropriate analysis pipeline based on variable types, distributions, and typical research questions in translation studies.</p>
<div class="explanation-panel" id="ai-suggestions-area">
<h4>Example Suggestions</h4>
<ul>
<li><strong>Hypothesis:</strong> "Professional translators produce significantly higher fluency scores than students."</li>
<li><strong>Recommended Test:</strong> Independent Samples t-test</li>
<li><strong>Variables:</strong> DV: <em>Fluency_Score</em> (Numerical), IV: <em>Translator_Type</em> (Categorical)</li>
</ul>
<ul>
<li><strong>Hypothesis:</strong> "Years of translation experience positively correlates with overall translation quality."</li>
<li><strong>Recommended Test:</strong> Pearson Correlation</li>
<li><strong>Variables:</strong> Years_Experience, Quality_Score</li>
</ul>
</div>
<div style="margin-top: 1rem;">
<button class="btn" onclick="generateAISuggestionsFromData()">Generate AI Hypothesis Suggestions</button>
</div>
</div>
</div>
<!-- Statistical Test Selection -->
<div class="card" id="test-selection-card" style="display: none;">
<div class="section-title">
<div class="number">4</div>
<h2>Select Statistical Test</h2>
</div>
<div class="section">
<p>Choose the appropriate statistical test for your research question.</p>
<div class="tabs">
<div class="tab active" data-tab="compare-groups">Compare Groups</div>
<div class="tab" data-tab="anova">ANOVA</div>
<div class="tab" data-tab="correlation">Correlation</div>
<div class="tab" data-tab="regression">Regression</div>
</div>
<div class="tab-content active" id="compare-groups">
<div style="text-align:center; margin-top: 1rem;">
<img alt="T-test schematic" src="https://via.placeholder.com/500x200?text=Independent+Samples+t-test+Diagram" style="max-width:100%; border:1px solid #ccc; border-radius:6px;"/>
<p class="help-text">Diagram: Compares means between two independent groups on one dependent variable.</p>
</div>
<h3>Comparing Two Groups</h3>
<div class="input-group">
<label>Select Test Type:</label>
<div class="radio-container">
<input checked="" id="independent-ttest" name="ttest-type" type="radio" value="independent"/>
<label for="independent-ttest">Independent Samples t-test (Between-subjects)</label>
</div>
<div class="radio-container">
<input id="paired-ttest" name="ttest-type" type="radio" value="paired"/>
<label for="paired-ttest">Paired Samples t-test (Within-subjects)</label>
</div>
<p class="help-text">Choose "Independent" when comparing different groups, "Paired" when comparing the same group in different conditions.</p>
</div>
<div class="explanation-panel">
<h4>When to use t-tests</h4>
<p>Use a t-test when comparing means between two groups or conditions. For example, comparing translation quality scores between professional and student translators, or comparing comprehension scores before and after translation revision.</p>
</div>
</div>
<div class="tab-content" id="anova">
<div style="text-align:center; margin-top: 1rem;">
<img alt="ANOVA schematic" src="https://via.placeholder.com/500x200?text=One-way+ANOVA+Diagram" style="max-width:100%; border:1px solid #ccc; border-radius:6px;"/>
<p class="help-text">Diagram: Compares means across three or more groups.</p>
</div>
<h3>Analysis of Variance (ANOVA)</h3>
<div class="input-group">
<label>Select ANOVA Type:</label>
<div class="radio-container">
<input checked="" id="one-way-anova" name="anova-type" type="radio" value="one-way"/>
<label for="one-way-anova">One-way ANOVA</label>
</div>
<div class="radio-container">
<input id="two-way-anova" name="anova-type" type="radio" value="two-way"/>
<label for="two-way-anova">Two-way ANOVA</label>
</div>
<p class="help-text">Choose "One-way" when examining one factor, "Two-way" when examining two factors and their interaction.</p>
</div>
<div class="explanation-panel">
<h4>When to use ANOVA</h4>
<p>Use ANOVA when comparing three or more groups or when examining the impact of multiple factors. For example, comparing translation quality across different language pairs or analyzing the effects of translator experience and text type on translation accuracy.</p>
</div>
</div>
<div class="tab-content" id="correlation">
<h3>Correlation Analysis</h3>
<div class="input-group">
<label>Select Correlation Type:</label>
<div class="radio-container">
<input checked="" id="pearson-correlation" name="correlation-type" type="radio" value="pearson"/>
<label for="pearson-correlation">Pearson's Correlation (Parametric)</label>
</div>
<div class="radio-container">
<input id="spearman-correlation" name="correlation-type" type="radio" value="spearman"/>
<label for="spearman-correlation">Spearman's Correlation (Non-parametric)</label>
</div>
<p class="help-text">Choose "Pearson's" for normally distributed data, "Spearman's" for ordinal data or when assumptions are violated.</p>
</div>
<div class="explanation-panel">
<h4>When to use Correlation</h4>
<p>Use correlation analysis to examine relationships between continuous variables. For example, exploring the relationship between years of translation experience and translation quality, or between source text complexity and translation time.</p>
</div>
</div>
<div class="tab-content" id="regression">
<h3>Regression Analysis</h3>
<div class="input-group">
<label>Select Regression Type:</label>
<div class="radio-container">
<input checked="" id="linear-regression" name="regression-type" type="radio" value="linear"/>
<label for="linear-regression">Linear Regression</label>
</div>
<div class="radio-container">
<input id="multiple-regression" name="regression-type" type="radio" value="multiple"/>
<label for="multiple-regression">Multiple Regression</label>
</div>
<p class="help-text">Choose "Linear" for one predictor variable, "Multiple" for several predictors.</p>
</div>
<div class="explanation-panel">
<h4>When to use Regression</h4>
<p>Use regression analysis to predict one variable based on one or more predictors. For example, predicting translation quality based on translator experience, source text complexity, or time spent on translation.</p>
</div>
</div>
<button class="btn btn-large" id="continue-to-variables">Continue to Select Variables</button>
</div>
</div>
<!-- Variable Selection -->
<div class="card" id="variable-selection-card" style="display: none;">
<div class="section-title">
<div class="number">5</div>
<h2>Select Variables for Analysis</h2>
</div>
<div class="section">
<div class="test-options" id="independent-ttest-vars">
<h3>Independent Samples t-test Variables</h3>
<div class="input-group">
<label for="ind-ttest-dv">Dependent Variable (Measurement):</label>
<select class="variable-select" id="ind-ttest-dv"></select>
<p class="help-text">The continuous variable you're measuring (e.g., translation quality score, reading time).</p>
</div>
<div class="input-group">
<label for="ind-ttest-grouping">Grouping Variable:</label>
<select class="variable-select" id="ind-ttest-grouping"></select>
<p class="help-text">The categorical variable that defines your groups (e.g., translator type, language pair).</p>
</div>
</div>
<div class="test-options" id="paired-ttest-vars">
<h3>Paired Samples t-test Variables</h3>
<div class="input-group">
<label for="paired-ttest-var1">First Measurement:</label>
<select class="variable-select" id="paired-ttest-var1"></select>
<p class="help-text">Measurement from first condition (e.g., pre-test score).</p>
</div>
<div class="input-group">
<label for="paired-ttest-var2">Second Measurement:</label>
<select class="variable-select" id="paired-ttest-var2"></select>
<p class="help-text">Measurement from second condition (e.g., post-test score).</p>
</div>
</div>
<div class="test-options" id="one-way-anova-vars">
<h3>One-way ANOVA Variables</h3>
<div class="input-group">
<label for="one-way-dv">Dependent Variable:</label>
<select class="variable-select" id="one-way-dv"></select>
<p class="help-text">The continuous variable you're measuring across groups.</p>
</div>
<div class="input-group">
<label for="one-way-factor">Factor (Independent Variable):</label>
<select class="variable-select" id="one-way-factor"></select>
<p class="help-text">The categorical variable with 3+ groups (e.g., translator experience level).</p>
</div>
</div>
<div class="test-options" id="two-way-anova-vars">
<h3>Two-way ANOVA Variables</h3>
<div class="input-group">
<label for="two-way-dv">Dependent Variable:</label>
<select class="variable-select" id="two-way-dv"></select>
<p class="help-text">The continuous variable you're measuring.</p>
</div>
<div class="input-group">
<label for="two-way-factor1">First Factor:</label>
<select class="variable-select" id="two-way-factor1"></select>
<p class="help-text">First categorical independent variable (e.g., translator type).</p>
</div>
<div class="input-group">
<label for="two-way-factor2">Second Factor:</label>
<select class="variable-select" id="two-way-factor2"></select>
<p class="help-text">Second categorical independent variable (e.g., text type).</p>
</div>
</div>
<div class="test-options" id="correlation-vars">
<h3>Correlation Variables</h3>
<div class="input-group">
<label for="correlation-var1">First Variable:</label>
<select class="variable-select" id="correlation-var1"></select>
<p class="help-text">First continuous variable (e.g., years of experience).</p>
</div>
<div class="input-group">
<label for="correlation-var2">Second Variable:</label>
<select class="variable-select" id="correlation-var2"></select>
<p class="help-text">Second continuous variable (e.g., translation quality score).</p>
</div>
</div>
<div class="test-options" id="regression-vars">
<h3>Regression Variables</h3>
<div class="input-group">
<label for="regression-dv">Dependent Variable:</label>
<select class="variable-select" id="regression-dv"></select>
<p class="help-text">The outcome variable you want to predict.</p>
</div>
<div class="input-group">
<label for="regression-iv">Independent Variable(s):</label>
<select class="variable-select" id="regression-iv" multiple=""></select>
<p class="help-text">The predictor variables (hold Ctrl/Cmd to select multiple for multiple regression).</p>
</div>
</div>
<div class="start-analysis-btn">
<button class="btn btn-large" id="analyze-btn">Run Analysis</button>
</div>
</div>
</div>
<!-- Analysis Results -->
<div class="card" id="results-card" style="display: none;">
<!-- AI-enhanced Visualization with OpenAI API -->
<div style="text-align:center; margin-top:1rem">
  <button class="btn btn-secondary" onclick="runLLMAutoChart()">ðŸ§  Suggest Visualization via AI</button>

<script>
async function generateChartFromLLM(columns, dataPreview, testType) {
  const apiKey = document.getElementById("api-key").value.trim();
  if (!apiKey) {
    showMessage("api-status", "Please enter your OpenAI API key", "error");
    return;
  }

  const prompt = `You are a data visualization assistant. ONLY return valid JSON.\n
Given the columns: ${columns.join(", ")},\n
and sample data: ${JSON.stringify(dataPreview.slice(0, 5))},\n
and a test type: ${testType},\n
Suggest an appropriate chart with the following fields:\n
{\n  "chartType": "bar",\n  "x": "Translator_Type",\n  "y": "Fluency_Score",\n
  "title": "Fluency Score by Translator Type",\n  "annotations": ["p = 0.034", "Cohen's d = 0.62"]\n}\n
Only output valid JSON, no explanation.`;

  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${apiKey}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model: "gpt-4",
      messages: [{ role: "user", content: prompt }],
      temperature: 0.3
    })
  });

  const result = await response.json();
  const content = result.choices[0].message.content.trim();
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    logToConsole("LLM response does not contain valid JSON.");
    return;
  }

  try {
    const json = JSON.parse(jsonMatch[0]);
    renderChartFromLLMSuggestion(json);
  } catch (err) {
    logToConsole("Failed to parse extracted JSON: " + err.message);
  }
}

function renderChartFromLLMSuggestion(suggestion) {
  const ctx = document.getElementById("main-chart").getContext("2d");
  if (mainChart) mainChart.destroy();

  const grouped = {};
  dataTable.forEach(row => {
    const x = row[suggestion.x];
    const y = parseFloat(row[suggestion.y]);
    if (!grouped[x]) grouped[x] = [];
    if (!isNaN(y)) grouped[x].push(y);
  });

  const labels = Object.keys(grouped);
  const datasets = labels.map(label => {
    const values = grouped[label];
    return values.length > 0 ? (values.reduce((a, b) => a + b, 0) / values.length).toFixed(2) : 0;
  });

  mainChart = new Chart(ctx, {
    type: suggestion.chartType || "bar",
    data: {
      labels: labels,
      datasets: [{
        label: suggestion.y,
        data: datasets
      }]
    },
    options: {
      responsive: true,
      plugins: {
        title: {
          display: true,
          text: suggestion.title || "Suggested Chart"
        },
        tooltip: {
          callbacks: {
            afterBody: function() {
              return suggestion.annotations ? suggestion.annotations.join("\n") : "";
            }
          }
        }
      }
    }
  });
  logToConsole("LLM-generated chart rendered.");
}

function runLLMAutoChart() {
  if (!dataTable || !columns || dataTable.length === 0) return;
  generateChartFromLLM(columns, dataTable, currentTest);
}
</script>
</div>

<div class="section-title">
<div class="number">6</div>
<h2>Analysis Results</h2>
</div>
<div class="section">
<div class="tabs">
<div class="tab active" data-tab="summary">Summary</div>
<div class="tab" data-tab="visualizations">Visualizations</div>
<div class="tab" data-tab="detailed-stats">Detailed Statistics</div>
<div class="tab" data-tab="apa-report">APA Report</div>
</div>
<div class="tab-content active" id="summary">
<h3>Summary of Results</h3>
<div id="results-summary"></div>
<div class="cards-grid" id="stat-cards">
<!-- Stat cards will be inserted here -->
</div>
</div>
<div class="tab-content" id="visualizations">
<h4>ðŸ“Š Visualization Overview</h4><h3>Visualizations</h3>
<div class="chart-container">
<div class="chart-enhanced-wrapper" style="padding: 1rem; background: #ffffff; border-radius: 8px; box-shadow: 0 1px 6px rgba(0,0,0,0.08); margin-bottom: 1rem;"><canvas id="main-chart"></canvas></div>
</div>
<div id="additional-charts"></div>
<div id="test-result-chart" style="margin-top: 1rem;">
<h4>ðŸ“Š Test Result Visualization</h4>
<canvas height="300" id="result-chart" width="600"></canvas>
</div>
</div>
<div class="tab-content" id="detailed-stats">
<h3>Detailed Statistical Output</h3>
<div id="detailed-results"></div>
</div>
<div class="tab-content" id="apa-report">
<h3>APA Style Results</h3>
<div class="apa-explainer-toggle" style="margin-bottom: 1rem;">
<label><input id="toggle-apa-explainer" style="margin-right: 0.5rem;" type="checkbox"/> Show Plain Language Explanation</label>
</div>
<script>
document.addEventListener('DOMContentLoaded', function() {
  const toggle = document.getElementById('toggle-apa-explainer');
  const apaBlock = document.getElementById('apa-formatted-results');
  if (toggle && apaBlock) {
    toggle.addEventListener('change', function() {
      if (this.checked) {
        const original = apaBlock.innerText;
        const rewritten = original
          .replace(/t\((\d+)\) = ([\d\.\-]+), p = ([\d\.]+), d = ([\d\.]+)/g,
                   'A t-test with $1 degrees of freedom showed a difference (t = $2, p = $3, Cohenâ€™s d = $4).')
          .replace(/F\((\d+), (\d+)\) = ([\d\.]+), p = ([\d\.]+), Î·Â² = ([\d\.]+)/g,
                   'An ANOVA indicated a significant effect (F($1, $2) = $3, p = $4, eta squared = $5).');
        apaBlock.setAttribute('data-original', original);
        apaBlock.innerText = rewritten + "\n\n(This is a simplified explanation)";
      } else {
        const original = apaBlock.getAttribute('data-original');
        if (original) apaBlock.innerText = original;
      }
    });
  }
});
</script>
<style>
#apa-formatted-results abbr[title] {
  border-bottom: 1px dotted #ccc;
  cursor: help;
}
</style>
<div class="apa-results" id="apa-formatted-results">
<!-- APA formatted results will be inserted here -->
</div>
<button class="btn btn-secondary" id="copy-apa-btn">Copy to Clipboard</button>
</div>
</div>
<div class="section">
<h3>Additional Options</h3>
<button class="btn" id="export-results-btn">Export Results</button>
<button class="btn btn-outline" id="new-analysis-btn">New Analysis</button>
</div>
</div>
<div class="section">
<h3>Download Outputs</h3>
<button class="btn btn-outline" onclick="downloadElement('results-summary', 'summary.html')">Download Summary</button>
<button class="btn btn-outline" onclick="downloadElement('main-chart', 'chart.png', true)">Download Chart</button>
<button class="btn btn-outline" onclick="downloadElement('apa-formatted-results', 'apa_report.txt')">Download APA Report</button>
<button class="btn btn-outline" onclick="downloadElement('detailed-results', 'details.html')">Download Full Stats</button>
</div>
<script>
function downloadElement(id, filename, isCanvas=false) {
  const el = document.getElementById(id);
  if (!el) return;
  if (isCanvas) {
    const canvas = el.tagName === "CANVAS" ? el : el.querySelector("canvas");
    const link = document.createElement('a');
    link.download = filename;
    link.href = canvas.toDataURL();
    link.click();
  } else {
    const content = el.innerHTML;
    const blob = new Blob([content], {type: 'text/html'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.download = filename;
    a.href = url;
    a.click();
    URL.revokeObjectURL(url);
  }
}
</script>
<!-- Log Console -->
<div class="card">
<h3>Processing Log</h3>
<div class="console" id="log-console">
<div class="log-entry"><span class="timestamp">[System]</span> StatLation initialized.</div>
</div>
</div>
</div>
<!-- Loading Spinner -->
<div class="spinner-container" id="loading-spinner">
<div class="spinner"></div>
<div class="spinner-text">Processing your data...</div>
</div>
<!-- Footer -->

<div class="footer">
  <div class="container">
    <p style="font-family: 'Poppins', sans-serif; font-size: 18px; font-weight: 500; color: #f1f5f9; margin-bottom: 0.5rem;">
      Â© 2025 <span style="color: #a5f3fc;">Hussein Abu-Rayyash</span> Â· All rights reserved.
    </p>
    <p style="font-family: 'Open Sans', sans-serif; font-size: 15px; color: #cbd5e1;">
      Built with ðŸ’¡ for translation and cognitive science researchers.
    </p>
    <div style="margin-top: 1rem;">
      <a href="mailto:husseinaburayyash@gmail.com" style="margin: 0 1rem; color: #facc15; font-weight: 600; text-decoration: none;">ðŸ“§ Contact</a>
      <a href="https://github.com/HusseinAbuRayyash" target="_blank" style="margin: 0 1rem; color: #38bdf8; font-weight: 600; text-decoration: none;">ðŸ’» GitHub</a>
      <a href="#top" style="margin: 0 1rem; color: #a78bfa; font-weight: 600; text-decoration: none;">ðŸ” Back to Top</a>
    </div>
  </div>
</div>

</div>
<div class="container">
</div>
<script>
    // Global variables
let variableRoles = {};
    let dataTable = [];
    let columns = [];
    let dataLoaded = false;
    let mainChart = null;
    let currentTest = 'independent';
    let currentTestCategory = 'compare-groups';
    
    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
      // Tab navigation
      const tabs = document.querySelectorAll('.tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', function() {
          // Remove active class from all tabs in this tab group
          const tabsGroup = this.parentElement.querySelectorAll('.tab');
          tabsGroup.forEach(t => t.classList.remove('active'));
          
          // Add active class to clicked tab
          this.classList.add('active');
          
          // Hide all tab content in this group
          const tabContents = document.querySelectorAll('.tab-content');
          tabContents.forEach(content => {
            if (content.id === this.dataset.tab) {
              content.classList.add('active');
            } else {
              content.classList.remove('active');
            }
          });
          
          // Update current test category and test
          if (this.dataset.tab) {
            currentTestCategory = this.dataset.tab;
            updateCurrentTest();
            
            if (dataLoaded) {
              showVariableSelectionForm();
            }
          }
        });
      });
      
      // Save API Key Button
      document.getElementById('save-api-key').addEventListener('click', function() {
        const apiKey = document.getElementById('api-key').value;
        if (apiKey.trim() === '') {
          showMessage('api-status', 'Please enter a valid API key', 'error');
          return;
        }
        
        // In a real application, you would validate the API key
        // Here we just simulate success
        showMessage('api-status', 'API key saved successfully', 'success');
        logToConsole('API key configured successfully');
        
        // Update step indicator
        updateStepStatus(1, 'completed');
        updateStepStatus(2, 'active');
      });
      
      // Upload Data Button
      document.getElementById('upload-btn').addEventListener('click', function() {
        const fileInput = document.getElementById('file-upload');
        if (!fileInput.files || fileInput.files.length === 0) {
          showMessage('file-status', 'Please select a file to upload', 'error');
          return;
        }
        
        const file = fileInput.files[0];
        const fileName = file.name;
        const fileExt = fileName.split('.').pop().toLowerCase();
        
        if (!['xlsx', 'xls', 'csv'].includes(fileExt)) {
          showMessage('file-status', 'Please upload an Excel or CSV file', 'error');
          return;
        }
        
        // Show loading spinner
        document.getElementById('loading-spinner').style.display = 'flex';
        
        logToConsole(`Uploading file: ${fileName}`);
        
        // Process the file based on its extension
        if (fileExt === 'csv') {
          processCSV(file);
        } else {
          processExcel(file);
        }
      });
      
      // Continue to Test Selection Button
      document.getElementById('continue-to-test').addEventListener('click', function() {
        document.getElementById('variable-list-card').style.display = 'none';
        document.getElementById('test-selection-card').style.display = 'block';
        
        // Update step indicator
        updateStepStatus(3, 'completed');
        updateStepStatus(4, 'active');
        
        logToConsole('Navigated to statistical test selection');
      });
      
      // Continue to Variable Selection Button
      document.getElementById('continue-to-variables').addEventListener('click', function() {
        document.getElementById('test-selection-card').style.display = 'none';
        document.getElementById('variable-selection-card').style.display = 'block';
        
        // Show the appropriate variable selection form based on the selected test
        showVariableSelectionForm();
        
        // Update step indicator
        updateStepStatus(4, 'completed');
        updateStepStatus(5, 'active');
        
        logToConsole(`Selected statistical test: ${currentTestCategory} - ${currentTest}`);
      });
      
      // Test type radio buttons
      document.querySelectorAll('input[name="ttest-type"]').forEach(radio => {
        radio.addEventListener('change', function() {
          currentTest = this.value;
          logToConsole(`Selected t-test type: ${currentTest}`);
        });
      });
      
      document.querySelectorAll('input[name="anova-type"]').forEach(radio => {
        radio.addEventListener('change', function() {
          currentTest = this.value;
          logToConsole(`Selected ANOVA type: ${currentTest}`);
        });
      });
      
      document.querySelectorAll('input[name="correlation-type"]').forEach(radio => {
        radio.addEventListener('change', function() {
          currentTest = this.value;
          logToConsole(`Selected correlation type: ${currentTest}`);
        });
      });
      
      document.querySelectorAll('input[name="regression-type"]').forEach(radio => {
        radio.addEventListener('change', function() {
          currentTest = this.value;
          logToConsole(`Selected regression type: ${currentTest}`);
        });
      });
      
      // Run Analysis Button
      document.getElementById('analyze-btn').addEventListener('click', function() {
        runAnalysis();
      });
      
      // New Analysis Button
      document.getElementById('new-analysis-btn').addEventListener('click', function() {
        // Hide results card and show test selection
        document.getElementById('results-card').style.display = 'none';
        document.getElementById('test-selection-card').style.display = 'block';
        
        // Update step indicator
        updateStepStatus(5, 'active');
        document.getElementById('step-5').classList.remove('completed');
        
        logToConsole('Starting new analysis');
      });
      
      // Export Results Button
      document.getElementById('export-results-btn').addEventListener('click', function() {
        exportResults();
      });
      
      // Copy APA Results Button
      document.getElementById('copy-apa-btn').addEventListener('click', function() {
        const apaText = document.getElementById('apa-formatted-results').innerText;
        navigator.clipboard.writeText(apaText).then(function() {
          showMessage('apa-formatted-results', 'Results copied to clipboard', 'success');
          logToConsole('APA results copied to clipboard');
        }, function() {
          showMessage('apa-formatted-results', 'Failed to copy results', 'error');
          logToConsole('Failed to copy APA results to clipboard', 'error');
        });
      });
      
      logToConsole('Application initialized successfully');
    });
    
    // Update the current test based on the selected category
    function updateCurrentTest() {
      switch (currentTestCategory) {
        case 'compare-groups':
          currentTest = document.querySelector('input[name="ttest-type"]:checked').value;
          break;
        case 'anova':
          currentTest = document.querySelector('input[name="anova-type"]:checked').value;
          break;
        case 'correlation':
          currentTest = document.querySelector('input[name="correlation-type"]:checked').value;
          break;
        case 'regression':
          currentTest = document.querySelector('input[name="regression-type"]:checked').value;
          break;
      }
    }
    
    // Update step status
    function updateStepStatus(stepNumber, status) {
      const stepItem = document.getElementById(`step-${stepNumber}`);
      
      // Remove all status classes
      stepItem.classList.remove('active', 'completed');
      
      // Add the appropriate class
      if (status) {
        stepItem.classList.add(status);
      }
    }
    
    // Process CSV file
    function processCSV(file) {
      const reader = new FileReader();
      
      reader.onload = function(e) {
        const content = e.target.result;
        
        // Parse CSV
        Papa.parse(content, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          complete: function(results) {
            dataTable = results.data;
            columns = results.meta.fields;
            
            logToConsole(`Processed CSV file with ${dataTable.length} rows and ${columns.length} columns`);
            
            // Display data preview and variable list
            displayDataPreview();
            displayVariableList();
        if (typeof buildVariableSummaryTable === 'function') buildVariableSummaryTable();
        populateVariableSelectorsByRole(currentTest);
            
            // Hide loading spinner
            document.getElementById('loading-spinner').style.display = 'none';
            
            showMessage('file-status', 'File uploaded and processed successfully', 'success');
            dataLoaded = true;
            
            // Update step indicator
            updateStepStatus(2, 'completed');
            updateStepStatus(3, 'active');
            
            // Show variable list card
            document.getElementById('variable-list-card').style.display = 'block';
          },
          error: function(error) {
            logToConsole(`Error processing CSV: ${error.message}`, 'error');
            document.getElementById('loading-spinner').style.display = 'none';
            showMessage('file-status', `Error processing file: ${error.message}`, 'error');
          }
        });
      };
      
      reader.onerror = function() {
        logToConsole('Error reading file', 'error');
        document.getElementById('loading-spinner').style.display = 'none';
        showMessage('file-status', 'Error reading file', 'error');
      };
      
      reader.readAsText(file);
    }
    
    // Process Excel file
    function processExcel(file) {
      const reader = new FileReader();
      
      reader.onload = function(e) {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        
        // Get the first sheet
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        
        // Convert to JSON
        dataTable = XLSX.utils.sheet_to_json(worksheet, { raw: false });
        columns = Object.keys(dataTable[0]);
        
        logToConsole(`Processed Excel file with ${dataTable.length} rows and ${columns.length} columns`);
        
        // Display data preview and variable list
        displayDataPreview();
        displayVariableList();
        if (typeof buildVariableSummaryTable === 'function') buildVariableSummaryTable();
        populateVariableSelectorsByRole(currentTest);
        
        // Hide loading spinner
        document.getElementById('loading-spinner').style.display = 'none';
        
        showMessage('file-status', 'File uploaded and processed successfully', 'success');
        dataLoaded = true;
        
        // Update step indicator
        updateStepStatus(2, 'completed');
        updateStepStatus(3, 'active');
        
        // Show variable list card
        document.getElementById('variable-list-card').style.display = 'block';
      };
      
      reader.onerror = function() {
        logToConsole('Error reading file', 'error');
        document.getElementById('loading-spinner').style.display = 'none';
        showMessage('file-status', 'Error reading file', 'error');
      };
      
      reader.readAsArrayBuffer(file);
    }
    
    // Display data preview
    function displayDataPreview() {
      const previewSection = document.getElementById('data-preview-section');
      const previewContainer = document.getElementById('data-preview');
      
      // Show the preview section
      previewSection.style.display = 'block';
      
      // Create table for preview
      let tableHTML = '<table><thead><tr>';
      
      // Add headers
      columns.forEach(col => {
        tableHTML += `<th>${col}</th>`;
      });
      
      tableHTML += '</tr></thead><tbody>';
      
      // Add rows (limit to 5 for preview)
      const rowLimit = dataTable.length;
      for (let i = 0; i < rowLimit; i++) {
        tableHTML += '<tr>';
        columns.forEach(col => {
          tableHTML += `<td>${dataTable[i][col] !== undefined && dataTable[i][col] !== null ? dataTable[i][col] : ''}</td>`;
        });
        tableHTML += '</tr>';
      }
      
      tableHTML += '</tbody></table>';
      
      // Add preview info text
      if (false) {
        tableHTML += `<p class="help-text">Showing 5 of ${dataTable.length} rows. Full dataset loaded successfully.</p>`;
      }
      
      previewContainer.innerHTML = tableHTML;
    }
    
    // Display variable list
    function displayVariableList() {
      const numericalContainer = document.getElementById('numerical-variables');
      const categoricalContainer = document.getElementById('categorical-variables');
      
      // Clear containers
      numericalContainer.innerHTML = '';
      categoricalContainer.innerHTML = '';
      
      // Categorize and display variables
      columns.forEach(column => {
        const type = inferColumnType(column);
        const uniqueCount = getUniqueValueCount(column);
        const item = document.createElement('div');
        item.className = 'variable-item';
        
        item.innerHTML = `
          <span>${column}</span>
          <span class="variable-type type-${type.toLowerCase()}">${type}</span>
        `;
        
        if (type === 'Numerical') {
          numericalContainer.appendChild(item);
        } else {
          categoricalContainer.appendChild(item);
        }
      });
      
      logToConsole(`Categorized variables: ${getNumericalColumns().length} numerical, ${getCategoricalColumns().length} categorical`);
    }
    
    // Infer column type (numerical, categorical, etc.)
    function inferColumnType(column) {
      // Check first few non-null values
      const values = dataTable
        .map(row => row[column])
        .filter(val => val !== null && val !== undefined && val !== '')
        .slice(0, 20);
      
      if (values.length === 0) return 'Text';
      
      // Check if all values are numbers
      const allNumbers = values.every(val => {
        const num = parseFloat(val);
        return !isNaN(num) && isFinite(num);
      });
      
      if (allNumbers) {
        // If there are many unique values, it's likely numerical
        const uniqueValues = new Set(values);
        if (uniqueValues.size > Math.min(10, values.length / 2)) {
          return 'Numerical';
        }
        // Few unique values means it's likely categorical even if numeric
        return 'Categorical';
      }
      
      // Check for date format
      const datePattern = /^\d{1,4}[-/]\d{1,2}[-/]\d{1,4}$|^\d{1,2}[-/]\d{1,2}[-/]\d{2,4}$/;
      const allDates = values.every(val => datePattern.test(String(val)));
      
      if (allDates) return 'Date';
      
      // Default to categorical
      return 'Categorical';
    }
    
    // Get the number of unique values in a column
    function getUniqueValueCount(column) {
      const uniqueValues = new Set();
      
      dataTable.forEach(row => {
        if (row[column] !== null && row[column] !== undefined) {
          uniqueValues.add(String(row[column]));
        }
      });
      
      return uniqueValues.size;
    }
    
    // Get all unique values from a column
    function getUniqueValues(column) {
      const uniqueValues = new Set();
      
      dataTable.forEach(row => {
        if (row[column] !== null && row[column] !== undefined) {
          uniqueValues.add(row[column]);
        }
      });
      
      return [...uniqueValues];
    }
    
    // Get all numerical columns
    function getNumericalColumns() {
      return columns.filter(col => inferColumnType(col) === 'Numerical');
    }
    
    // Get all categorical columns
    function getCategoricalColumns() {
      return columns.filter(col => inferColumnType(col) === 'Categorical');
    }
    
    // Show variable selection form based on selected test
    function showVariableSelectionForm() {
      // Hide all test option forms
      document.querySelectorAll('.test-options').forEach(form => {
        form.style.display = 'none';
      });
      
      // Show the appropriate form based on selected test
      let formId = '';
      
      switch (currentTestCategory) {
        case 'compare-groups':
          formId = currentTest === 'independent' ? 'independent-ttest-vars' : 'paired-ttest-vars';
          break;
        case 'anova':
          formId = currentTest === 'one-way' ? 'one-way-anova-vars' : 'two-way-anova-vars';
          break;
        case 'correlation':
          formId = 'correlation-vars';
          break;
        case 'regression':
          formId = 'regression-vars';
          break;
      }
      
      const form = document.getElementById(formId);
      if (form) {
        form.style.display = 'block';
        populateVariableSelectors(formId);
      }
    }
    
    // Populate variable selectors with column names
    function populateVariableSelectors(formId) {
      // Get all selectors in this form
      const selectors = document.querySelectorAll(`#${formId} .variable-select`);
      
      selectors.forEach(selector => {
        // Save current selection if any
        const currentValue = selector.value;
        
        // Clear options
        selector.innerHTML = '';
        
        // Filter columns based on selector requirements
        let filteredColumns = [...columns];
        
        // If this is a grouping or factor variable, only show categorical variables
        if (selector.id.includes('grouping') || selector.id.includes('factor')) {
          filteredColumns = getCategoricalColumns();
        }
        
        // If this is a continuous variable (DV, measurement, etc.), only show numerical variables
        if (selector.id.includes('dv') || 
            selector.id.includes('var1') || 
            selector.id.includes('var2') ||
            selector.id.includes('regression-dv')) {
          filteredColumns = getNumericalColumns();
        }
        
        // Add options
        filteredColumns.forEach(col => {
          const option = document.createElement('option');
          option.value = col;
          option.textContent = col;
          selector.appendChild(option);
        });
        
        // Restore selection if it exists in the new options
        if (currentValue && filteredColumns.includes(currentValue)) {
          selector.value = currentValue;
        }
      });
      
      logToConsole(`Populated variable selectors for ${formId}`);
    }
    
    // Run the selected analysis
    function runAnalysis() {
      // Show loading spinner
      document.getElementById('loading-spinner').style.display = 'flex';
      
      logToConsole(`Running ${currentTestCategory} analysis: ${currentTest}`);
      
      // Get variables based on selected test
      let variables = {};
      let analysisResult = {};
      
      switch (currentTestCategory) {
        case 'compare-groups':
          if (currentTest === 'independent') {
            variables.dv = document.getElementById('ind-ttest-dv').value;
            variables.grouping = document.getElementById('ind-ttest-grouping').value;
            analysisResult = runIndependentTTest(variables.dv, variables.grouping);
          } else { // paired
            variables.var1 = document.getElementById('paired-ttest-var1').value;
            variables.var2 = document.getElementById('paired-ttest-var2').value;
            analysisResult = runPairedTTest(variables.var1, variables.var2);
          }
          break;
          
        case 'anova':
          if (currentTest === 'one-way') {
            variables.dv = document.getElementById('one-way-dv').value;
            variables.factor = document.getElementById('one-way-factor').value;
            analysisResult = runOneWayANOVA(variables.dv, variables.factor);
          } else { // two-way
            variables.dv = document.getElementById('two-way-dv').value;
            variables.factor1 = document.getElementById('two-way-factor1').value;
            variables.factor2 = document.getElementById('two-way-factor2').value;
            analysisResult = runTwoWayANOVA(variables.dv, variables.factor1, variables.factor2);
          }
          break;
          
        case 'correlation':
          variables.var1 = document.getElementById('correlation-var1').value;
          variables.var2 = document.getElementById('correlation-var2').value;
          if (currentTest === 'pearson') {
            analysisResult = runPearsonCorrelation(variables.var1, variables.var2);
          } else { // spearman
            analysisResult = runSpearmanCorrelation(variables.var1, variables.var2);
          }
          break;
          
        case 'regression':
          variables.dv = document.getElementById('regression-dv').value;
          
          // For multiple regression, get all selected options
          const ivSelect = document.getElementById('regression-iv');
          const selectedOptions = Array.from(ivSelect.selectedOptions).map(option => option.value);
          
          variables.ivs = selectedOptions;
          
          if (currentTest === 'linear' && selectedOptions.length === 1) {
            analysisResult = runLinearRegression(variables.dv, selectedOptions[0]);
          } else { // multiple regression
            analysisResult = runMultipleRegression(variables.dv, selectedOptions);
          }
          break;
      }
      
      // Hide loading spinner
      document.getElementById('loading-spinner').style.display = 'none';
      
      // Update step indicator
      updateStepStatus(5, 'completed');
      
      // Hide variable selection card and show results card
      document.getElementById('variable-selection-card').style.display = 'none';
      document.getElementById('results-card').style.display = 'block';
      
      // Display results
      displayResults(analysisResult, variables);
      
      logToConsole('Analysis completed successfully');
    }
    
    // Display analysis results
    function displayResults(results, variables) {
      // Populate results summary
      const summaryElement = document.getElementById('results-summary');
      summaryElement.innerHTML = `<h4>${getTestTitle(currentTestCategory, currentTest)}</h4>`;
      summaryElement.innerHTML += `<p>${results.summary}</p>`;
      
      // Create stat cards
      const statCardsContainer = document.getElementById('stat-cards');
      statCardsContainer.innerHTML = '';
      
      // Add key statistics as cards
      for (const key in results.keyStats) {
        if (results.keyStats.hasOwnProperty(key)) {
          const card = document.createElement('div');
          card.className = 'stat-card';
          
          card.innerHTML = `
            <div class="title">${key}</div>
            <div class="value">${results.keyStats[key].value}</div>
            <div class="description">${results.keyStats[key].description}</div>
          `;
          
          statCardsContainer.appendChild(card);
        }
      }
      
      // Create visualizations
      createVisualizations(results, variables);
      
      // Populate detailed statistics
      const detailedElement = document.getElementById('detailed-results');
      detailedElement.innerHTML = '';
      
      if (results.tables && results.tables.length > 0) {
        results.tables.forEach(table => {
          detailedElement.innerHTML += `<h4>${table.title}</h4>`;
          detailedElement.innerHTML += table.html;
        });
      } else {
        detailedElement.innerHTML += `<p>${results.details}</p>`;
      }
      
      // Populate APA results
      const apaElement = document.getElementById('apa-formatted-results');
      apaElement.innerHTML = results.apaText;
    }
    
    // Get the title for the current test
    function getTestTitle(category, test) {
      switch (category) {
        case 'compare-groups':
          return test === 'independent' ? 'Independent Samples t-test' : 'Paired Samples t-test';
        case 'anova':
          return test === 'one-way' ? 'One-way ANOVA' : 'Two-way ANOVA';
        case 'correlation':
          return test === 'pearson' ? 'Pearson Correlation' : 'Spearman Correlation';
        case 'regression':
          return test === 'linear' ? 'Linear Regression' : 'Multiple Regression';
        default:
          return 'Statistical Analysis';
      }
    }
    
    // Create visualizations based on results
    function createVisualizations(results, variables) {
      const chartCanvas = document.getElementById('main-chart');
      const additionalChartsContainer = document.getElementById('additional-charts');
      
      // Destroy existing chart if any
      if (mainChart) {
        mainChart.destroy();
      }
      
      // Clear additional charts
      additionalChartsContainer.innerHTML = '';
      
      // Create main chart based on test type
      switch (currentTestCategory) {
        case 'compare-groups':
          if (currentTest === 'independent') {
            createGroupComparisonChart(variables.dv, variables.grouping);
          } else { // paired
            createPairedComparisonChart(variables.var1, variables.var2);
          }
          break;
          
        case 'anova':
          if (currentTest === 'one-way') {
            createOneWayANOVAChart(variables.dv, variables.factor);
          } else { // two-way
            createTwoWayANOVAChart(variables.dv, variables.factor1, variables.factor2);
            
            // Add interaction plot as additional chart
            const interactionCanvas = document.createElement('canvas');
            interactionCanvas.id = 'interaction-chart';
            
            const interactionContainer = document.createElement('div');
            interactionContainer.className = 'chart-container';
            interactionContainer.appendChild(interactionCanvas);
            
            const interactionTitle = document.createElement('h4');
            interactionTitle.textContent = 'Interaction Plot';
            
            additionalChartsContainer.appendChild(interactionTitle);
            additionalChartsContainer.appendChild(interactionContainer);
            
            createInteractionPlot(variables.dv, variables.factor1, variables.factor2, interactionCanvas);
          }
          break;
          
        case 'correlation':
          createScatterPlot(variables.var1, variables.var2);
          break;
          
        case 'regression':
          if (variables.ivs.length === 1) {
            createRegressionPlot(variables.dv, variables.ivs[0]);
          } else {
            // For multiple regression, create a combined visualization
            createMultipleRegressionVisualization(variables.dv, variables.ivs);
          }
          break;
      }
    }
    
    // Create bar chart for group comparison (t-test)
    function createGroupComparisonChart(dvName, groupingName) {
      // Get unique groups
      const groups = getUniqueValues(groupingName);
      
      // Calculate means for each group
      const means = groups.map(group => {
        const groupData = dataTable.filter(row => row[groupingName] == group);
        return calculateMean(groupData.map(row => row[dvName]));
      });
      
      // Calculate standard errors for each group
      const stdErrors = groups.map(group => {
        const groupData = dataTable.filter(row => row[groupingName] == group);
        const values = groupData.map(row => row[dvName]);
        return calculateStandardError(values);
      });
      
      // Create chart
      mainChart = new Chart(document.getElementById('main-chart'), {
        type: 'bar',
        data: {
          labels: groups,
          datasets: [{
            label: dvName,
            data: means,
            backgroundColor: ['rgba(99, 102, 241, 0.7)', 'rgba(236, 72, 153, 0.7)'],
            borderColor: ['rgba(99, 102, 241, 1)', 'rgba(236, 72, 153, 1)'],
            borderWidth: 1,
            barPercentage: 0.6,
            categoryPercentage: 0.8
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `Mean ${dvName} by ${groupingName}`,
              font: {
                size: 16,
                weight: 'bold'
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `Mean: ${context.parsed.y.toFixed(2)}`;
                },
                afterLabel: function(context) {
                  const index = context.dataIndex;
                  return `SE: Â±${stdErrors[index].toFixed(2)}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: false,
              title: {
                display: true,
                text: dvName,
                font: {
                  weight: 'bold'
                }
              }
            },
            x: {
              title: {
                display: true,
                text: groupingName,
                font: {
                  weight: 'bold'
                }
              }
            }
          }
        }
      });
    }
    
    // Create paired bar chart for paired samples t-test
    function createPairedComparisonChart(var1Name, var2Name) {
      // Calculate means
      const mean1 = calculateMean(dataTable.map(row => row[var1Name]));
      const mean2 = calculateMean(dataTable.map(row => row[var2Name]));
      
      // Calculate standard errors
      const se1 = calculateStandardError(dataTable.map(row => row[var1Name]));
      const se2 = calculateStandardError(dataTable.map(row => row[var2Name]));
      
      // Create chart
      mainChart = new Chart(document.getElementById('main-chart'), {
        type: 'bar',
        data: {
          labels: [var1Name, var2Name],
          datasets: [{
            data: [mean1, mean2],
            backgroundColor: ['rgba(99, 102, 241, 0.7)', 'rgba(236, 72, 153, 0.7)'],
            borderColor: ['rgba(99, 102, 241, 1)', 'rgba(236, 72, 153, 1)'],
            borderWidth: 1,
            barPercentage: 0.6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            title: {
              display: true,
              text: `Comparison of Means`,
              font: {
                size: 16,
                weight: 'bold'
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `Mean: ${context.parsed.y.toFixed(2)}`;
                },
                afterLabel: function(context) {
                  const index = context.dataIndex;
                  const se = index === 0 ? se1 : se2;
                  return `SE: Â±${se.toFixed(2)}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: false,
              title: {
                display: true,
                text: 'Value',
                font: {
                  weight: 'bold'
                }
              }
            }
          }
        }
      });
    }
    
    // Create chart for one-way ANOVA
    function createOneWayANOVAChart(dvName, factorName) {
      // Get unique groups
      const groups = getUniqueValues(factorName);
      
      // Calculate means for each group
      const means = groups.map(group => {
        const groupData = dataTable.filter(row => row[factorName] == group);
        return calculateMean(groupData.map(row => row[dvName]));
      });
      
      // Calculate standard errors for each group
      const stdErrors = groups.map(group => {
        const groupData = dataTable.filter(row => row[factorName] == group);
        const values = groupData.map(row => row[dvName]);
        return calculateStandardError(values);
      });
      
      // Generate colors for groups
      const colors = groups.map((_, index) => getColorForIndex(index));
      const borderColors = groups.map((_, index) => getColorForIndex(index, 1));
      
      // Create chart
      mainChart = new Chart(document.getElementById('main-chart'), {
        type: 'bar',
        data: {
          labels: groups,
          datasets: [{
            label: dvName,
            data: means,
            backgroundColor: colors,
            borderColor: borderColors,
            borderWidth: 1,
            barPercentage: 0.6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `Mean ${dvName} by ${factorName} (One-Way ANOVA)`,
              font: {
                size: 16,
                weight: 'bold'
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `Mean: ${context.parsed.y.toFixed(2)}`;
                },
                afterLabel: function(context) {
                  const index = context.dataIndex;
                  return `SE: Â±${stdErrors[index].toFixed(2)}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: false,
              title: {
                display: true,
                text: dvName,
                font: {
                  weight: 'bold'
                }
              }
            },
            x: {
              title: {
                display: true,
                text: factorName,
                font: {
                  weight: 'bold'
                }
              }
            }
          }
        }
      });
    }
    
    // Create chart for two-way ANOVA (main effects)
    function createTwoWayANOVAChart(dvName, factor1Name, factor2Name) {
      // Get unique groups for factor 1
      const factor1Values = getUniqueValues(factor1Name);
      
      // Calculate overall means for each level of factor 1
      const factor1Means = factor1Values.map(value => {
        const filteredData = dataTable.filter(row => row[factor1Name] == value);
        return calculateMean(filteredData.map(row => row[dvName]));
      });
      
      // Get unique values for factor 2
      const factor2Values = getUniqueValues(factor2Name);
      
      // Calculate overall means for each level of factor 2
      const factor2Means = factor2Values.map(value => {
        const filteredData = dataTable.filter(row => row[factor2Name] == value);
        return calculateMean(filteredData.map(row => row[dvName]));
      });
      
      // Create datasets for the main effects
      const datasets = [
        {
          label: `${factor1Name} Main Effect`,
          data: factor1Means.map((mean, i) => ({ x: `${factor1Name}: ${factor1Values[i]}`, y: mean })),
          backgroundColor: 'rgba(99, 102, 241, 0.7)',
          borderColor: 'rgba(99, 102, 241, 1)',
          borderWidth: 1,
          barPercentage: 0.4,
          categoryPercentage: 0.5
        },
        {
          label: `${factor2Name} Main Effect`,
          data: factor2Means.map((mean, i) => ({ x: `${factor2Name}: ${factor2Values[i]}`, y: mean })),
          backgroundColor: 'rgba(236, 72, 153, 0.7)',
          borderColor: 'rgba(236, 72, 153, 1)',
          borderWidth: 1,
          barPercentage: 0.4,
          categoryPercentage: 0.5
        }
      ];
      
      // Combine all labels
      const labels = [
        ...factor1Means.map((_, i) => `${factor1Name}: ${factor1Values[i]}`),
        ...factor2Means.map((_, i) => `${factor2Name}: ${factor2Values[i]}`)
      ];
      
      // Create chart
      mainChart = new Chart(document.getElementById('main-chart'), {
        type: 'bar',
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `Main Effects: ${dvName} by ${factor1Name} and ${factor2Name}`,
              font: {
                size: 16,
                weight: 'bold'
              }
            }
          },
          scales: {
            y: {
              beginAtZero: false,
              title: {
                display: true,
                text: dvName,
                font: {
                  weight: 'bold'
                }
              }
            },
            x: {
              title: {
                display: true,
                text: 'Factors',
                font: {
                  weight: 'bold'
                }
              }
            }
          }
        }
      });
    }
    
    // Create interaction plot for two-way ANOVA
    function createInteractionPlot(dvName, factor1Name, factor2Name, canvas) {
      // Get unique values for both factors
      const factor1Values = getUniqueValues(factor1Name);
      const factor2Values = getUniqueValues(factor2Name);
      
      // Create datasets for each level of factor2
      const datasets = factor2Values.map((factor2Value, index) => {
        // For each level of factor1, get mean of DV where factor2 = factor2Value
        const data = factor1Values.map(factor1Value => {
          const filteredData = dataTable.filter(row => 
            row[factor1Name] == factor1Value && 
            row[factor2Name] == factor2Value
          );
          
          return calculateMean(filteredData.map(row => row[dvName]));
        });
        
        // Create a dataset with different colors
        return {
          label: `${factor2Name} = ${factor2Value}`,
          data: data,
          borderColor: getColorForIndex(index),
          backgroundColor: getColorForIndex(index, 0.2),
          borderWidth: 2,
          pointBackgroundColor: getColorForIndex(index),
          pointRadius: 5,
          fill: false,
          tension: 0.1
        };
      });
      
      // Create the interaction plot
      new Chart(canvas, {
        type: 'line',
        data: {
          labels: factor1Values,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `Interaction between ${factor1Name} and ${factor2Name}`,
              font: {
                size: 16,
                weight: 'bold'
              }
            }
          },
          scales: {
            y: {
              title: {
                display: true,
                text: dvName,
                font: {
                  weight: 'bold'
                }
              }
            },
            x: {
              title: {
                display: true,
                text: factor1Name,
                font: {
                  weight: 'bold'
                }
              }
            }
          }
        }
      });
    }
    
    // Create scatter plot for correlation
    function createScatterPlot(var1Name, var2Name) {
      // Extract data pairs
      const data = dataTable.map(row => ({
        x: row[var1Name],
        y: row[var2Name]
      })).filter(point => !isNaN(point.x) && !isNaN(point.y));
      
      // Calculate correlation coefficient
      const x = dataTable.map(row => row[var1Name]).filter(val => !isNaN(val));
      const y = dataTable.map(row => row[var2Name]).filter(val => !isNaN(val));
      const r = calculateCorrelation(x, y);
      
      // Calculate regression line
      const xMean = calculateMean(x);
      const yMean = calculateMean(y);
      const slope = calculateSlope(x, y);
      const intercept = yMean - slope * xMean;
      
      // Create regression line points
      const xMin = Math.min(...x);
      const xMax = Math.max(...x);
      const regressionPoints = [
        { x: xMin, y: intercept + slope * xMin },
        { x: xMax, y: intercept + slope * xMax }
      ];
      
      mainChart = new Chart(document.getElementById('main-chart'), {
        type: 'scatter',
        data: {
          datasets: [
            {
              label: 'Data Points',
              data: data,
              backgroundColor: 'rgba(99, 102, 241, 0.7)',
              pointRadius: 6,
              pointHoverRadius: 8
            },
            {
              label: 'Regression Line',
              data: regressionPoints,
              type: 'line',
              borderColor: 'rgba(236, 72, 153, 0.7)',
              borderWidth: 2,
              pointRadius: 0,
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `Correlation between ${var1Name} and ${var2Name} (r = ${r.toFixed(3)})`,
              font: {
                size: 16,
                weight: 'bold'
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: var1Name,
                font: {
                  weight: 'bold'
                }
              }
            },
            y: {
              title: {
                display: true,
                text: var2Name,
                font: {
                  weight: 'bold'
                }
              }
            }
          }
        }
      });
    }
    
    // Create regression plot
    function createRegressionPlot(dvName, ivName) {
      // Extract data
      const data = dataTable.map(row => ({
        x: row[ivName],
        y: row[dvName]
      })).filter(point => !isNaN(point.x) && !isNaN(point.y));
      
      const x = data.map(point => point.x);
      const y = data.map(point => point.y);
      
      // Calculate regression parameters
      const slope = calculateSlope(x, y);
      const intercept = calculateIntercept(x, y);
      const r2 = calculateRSquared(x, y);
      
      // Create regression line points
      const xMin = Math.min(...x);
      const xMax = Math.max(...x);
      const regressionPoints = [
        { x: xMin, y: intercept + slope * xMin },
        { x: xMax, y: intercept + slope * xMax }
      ];
      
      mainChart = new Chart(document.getElementById('main-chart'), {
        type: 'scatter',
        data: {
          datasets: [
            {
              label: 'Data Points',
              data: data,
              backgroundColor: 'rgba(99, 102, 241, 0.7)',
              pointRadius: 6,
              pointHoverRadius: 8
            },
            {
              label: 'Regression Line',
              data: regressionPoints,
              type: 'line',
              borderColor: 'rgba(236, 72, 153, 0.7)',
              borderWidth: 2,
              pointRadius: 0,
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `Linear Regression: ${dvName} = ${intercept.toFixed(2)} + ${slope.toFixed(2)}Ã—${ivName} (RÂ² = ${r2.toFixed(3)})`,
              font: {
                size: 16,
                weight: 'bold'
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: ivName,
                font: {
                  weight: 'bold'
                }
              }
            },
            y: {
              title: {
                display: true,
                text: dvName,
                font: {
                  weight: 'bold'
                }
              }
            }
          }
        }
      });
    }
    
    // Create multiple regression visualization
    function createMultipleRegressionVisualization(dvName, ivNames) {
      // For multiple regression, create a coefficient plot
      const coefficients = ivNames.map(ivName => {
        // Calculate standardized coefficient (beta)
        const x = dataTable.map(row => parseFloat(row[ivName])).filter(val => !isNaN(val));
        const y = dataTable.map(row => parseFloat(row[dvName])).filter(val => !isNaN(val));
        
        return estimateStandardizedCoefficient(x, y);
      });
      
      mainChart = new Chart(document.getElementById('main-chart'), {
        type: 'bar',
        data: {
          labels: ivNames,
          datasets: [{
            label: 'Standardized Coefficient (Î²)',
            data: coefficients,
            backgroundColor: coefficients.map(c => c >= 0 ? 'rgba(99, 102, 241, 0.7)' : 'rgba(236, 72, 153, 0.7)'),
            borderColor: coefficients.map(c => c >= 0 ? 'rgba(99, 102, 241, 1)' : 'rgba(236, 72, 153, 1)'),
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `Standardized Coefficients for ${dvName}`,
              font: {
                size: 16,
                weight: 'bold'
              }
            }
          },
          scales: {
            y: {
              title: {
                display: true,
                text: 'Standardized Coefficient (Î²)',
                font: {
                  weight: 'bold'
                }
              }
            },
            x: {
              title: {
                display: true,
                text: 'Predictor Variables',
                font: {
                  weight: 'bold'
                }
              }
            }
          }
        }
      });
    }
    
    // Export results to CSV
    function exportResults() {
      // Create a CSV string with the results
      let csvContent = 'data:text/csv;charset=utf-8,';
      
      // Add headers based on current test
      if (currentTestCategory === 'compare-groups') {
        csvContent += 'Group,N,Mean,Std. Deviation,Std. Error\n';
        
        if (currentTest === 'independent') {
          const dvName = document.getElementById('ind-ttest-dv').value;
          const groupingName = document.getElementById('ind-ttest-grouping').value;
          const groups = getUniqueValues(groupingName);
          
          groups.forEach(group => {
            const groupData = dataTable.filter(row => row[groupingName] == group);
            const values = groupData.map(row => row[dvName]);
            const n = values.length;
            const mean = calculateMean(values);
            const stdDev = calculateStandardDeviation(values);
            const stdError = calculateStandardError(values);
            
            csvContent += `${group},${n},${mean.toFixed(2)},${stdDev.toFixed(2)},${stdError.toFixed(2)}\n`;
          });
        } else { // paired
          const var1Name = document.getElementById('paired-ttest-var1').value;
          const var2Name = document.getElementById('paired-ttest-var2').value;
          
          const var1Values = dataTable.map(row => row[var1Name]);
          const var2Values = dataTable.map(row => row[var2Name]);
          
          csvContent += `${var1Name},${var1Values.length},${calculateMean(var1Values).toFixed(2)},${calculateStandardDeviation(var1Values).toFixed(2)},${calculateStandardError(var1Values).toFixed(2)}\n`;
          csvContent += `${var2Name},${var2Values.length},${calculateMean(var2Values).toFixed(2)},${calculateStandardDeviation(var2Values).toFixed(2)},${calculateStandardError(var2Values).toFixed(2)}\n`;
        }
      } else if (currentTestCategory === 'anova') {
        if (currentTest === 'one-way') {
          const dvName = document.getElementById('one-way-dv').value;
          const factorName = document.getElementById('one-way-factor').value;
          csvContent += `${factorName},N,Mean of ${dvName},Std. Deviation,Std. Error\n`;
          
          const groups = getUniqueValues(factorName);
          groups.forEach(group => {
            const groupData = dataTable.filter(row => row[factorName] == group);
            const values = groupData.map(row => row[dvName]);
            const n = values.length;
            const mean = calculateMean(values);
            const stdDev = calculateStandardDeviation(values);
            const stdError = calculateStandardError(values);
            
            csvContent += `${group},${n},${mean.toFixed(2)},${stdDev.toFixed(2)},${stdError.toFixed(2)}\n`;
          });
        } else { // two-way
          const dvName = document.getElementById('two-way-dv').value;
          const factor1Name = document.getElementById('two-way-factor1').value;
          const factor2Name = document.getElementById('two-way-factor2').value;
          
          csvContent += `${factor1Name},${factor2Name},N,Mean of ${dvName},Std. Deviation,Std. Error\n`;
          
          const factor1Values = getUniqueValues(factor1Name);
          const factor2Values = getUniqueValues(factor2Name);
          
          factor1Values.forEach(val1 => {
            factor2Values.forEach(val2 => {
              const cellData = dataTable.filter(row => row[factor1Name] == val1 && row[factor2Name] == val2);
              const values = cellData.map(row => row[dvName]);
              const n = values.length;
              
              if (n > 0) {
                const mean = calculateMean(values);
                const stdDev = calculateStandardDeviation(values);
                const stdError = calculateStandardError(values);
                
                csvContent += `${val1},${val2},${n},${mean.toFixed(2)},${stdDev.toFixed(2)},${stdError.toFixed(2)}\n`;
              }
            });
          });
        }
      } else if (currentTestCategory === 'correlation') {
        const var1Name = document.getElementById('correlation-var1').value;
        const var2Name = document.getElementById('correlation-var2').value;
        
        csvContent += `Subject,${var1Name},${var2Name}\n`;
        
        // Add individual data points
        dataTable.forEach((row, index) => {
          if (row[var1Name] !== undefined && row[var2Name] !== undefined) {
            csvContent += `${index + 1},${row[var1Name]},${row[var2Name]}\n`;
          }
        });
      } else if (currentTestCategory === 'regression') {
        const dvName = document.getElementById('regression-dv').value;
        const ivSelect = document.getElementById('regression-iv');
        const selectedIVs = Array.from(ivSelect.selectedOptions).map(option => option.value);
        
        // Add headers
        csvContent += `Subject,${dvName},${selectedIVs.join(',')}\n`;
        
        // Add individual data points
        dataTable.forEach((row, index) => {
          let rowData = `${index + 1},${row[dvName]}`;
          selectedIVs.forEach(iv => {
            rowData += `,${row[iv]}`;
          });
          csvContent += rowData + '\n';
        });
      }
      
      // Create a download link and trigger the download
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement('a');
      link.setAttribute('href', encodedUri);
      link.setAttribute('download', 'translation_analysis_results.csv');
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      logToConsole('Results exported to CSV');
    }
    
    // STATISTICAL ANALYSIS FUNCTIONS
    
    // Run independent samples t-test
    function runIndependentTTest(dvName, groupingName) {
      logToConsole(`Running independent samples t-test: ${dvName} by ${groupingName}`);
      
      // Get unique groups (should be 2 for t-test)
      const groups = getUniqueValues(groupingName);
      
      if (groups.length !== 2) {
        logToConsole(`Warning: Independent t-test expects 2 groups, but found ${groups.length}`, 'warning');
      }
      
      // Extract data for each group
      const group1Data = dataTable
        .filter(row => row[groupingName] === groups[0])
        .map(row => parseFloat(row[dvName]))
        .filter(val => !isNaN(val));
      
      const group2Data = dataTable
        .filter(row => row[groupingName] === groups[1])
        .map(row => parseFloat(row[dvName]))
        .filter(val => !isNaN(val));
      
      // Calculate statistics
      const n1 = group1Data.length;
      const n2 = group2Data.length;
      const mean1 = calculateMean(group1Data);
      const mean2 = calculateMean(group2Data);
      const sd1 = calculateStandardDeviation(group1Data);
      const sd2 = calculateStandardDeviation(group2Data);
      const se1 = sd1 / Math.sqrt(n1);
      const se2 = sd2 / Math.sqrt(n2);
      const meanDiff = mean1 - mean2;
      
      // Calculate pooled standard deviation (for equal variances)
      const pooledSD = Math.sqrt(((n1 - 1) * sd1 * sd1 + (n2 - 1) * sd2 * sd2) / (n1 + n2 - 2));
      
      // Calculate t-value
      const t = meanDiff / (pooledSD * Math.sqrt(1/n1 + 1/n2));
      
      // Calculate degrees of freedom
      const df = n1 + n2 - 2;
      
      // Calculate p-value using jStat
      const pValue = 2 * (1 - jStat.studentt.cdf(Math.abs(t), df));
      
      // Calculate Cohen's d (effect size)
      const cohensD = Math.abs(meanDiff) / pooledSD;
      
      // Create result object
      const result = {
        summary: `An independent samples t-test was conducted to compare ${dvName} between ${groups[0]} (n = ${n1}) and ${groups[1]} (n = ${n2}). There was a ${pValue < 0.05 ? 'significant' : 'non-significant'} difference in scores for ${groups[0]} (M = ${mean1.toFixed(2)}, SD = ${sd1.toFixed(2)}) and ${groups[1]} (M = ${mean2.toFixed(2)}, SD = ${sd2.toFixed(2)}); t(${df}) = ${t.toFixed(2)}, p = ${formatPValue(pValue)}, d = ${cohensD.toFixed(2)}.`,
        
        keyStats: {
          't-value': { value: t.toFixed(2), description: 'Test statistic' },
          'p-value': { value: formatPValue(pValue), description: 'Probability value' },
          'Mean Difference': { value: meanDiff.toFixed(2), description: `${groups[0]} minus ${groups[1]}` },
          'Cohen\'s d': { value: cohensD.toFixed(2), description: 'Effect size (standardized mean difference)' }
        },
        
        details: `
          Group 1 (${groups[0]}): n = ${n1}, Mean = ${mean1.toFixed(2)}, SD = ${sd1.toFixed(2)}, SE = ${se1.toFixed(2)}
          Group 2 (${groups[1]}): n = ${n2}, Mean = ${mean2.toFixed(2)}, SD = ${sd2.toFixed(2)}, SE = ${se2.toFixed(2)}
          Mean Difference: ${meanDiff.toFixed(2)}
          t(${df}) = ${t.toFixed(3)}
          p = ${formatPValue(pValue)}
          Cohen's d = ${cohensD.toFixed(3)}
        `,
        
        tables: [
          {
            title: 'Group Statistics',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>${groupingName}</th>
                    <th>N</th>
                    <th>Mean</th>
                    <th>Std. Deviation</th>
                    <th>Std. Error Mean</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>${groups[0]}</td>
                    <td>${n1}</td>
                    <td>${mean1.toFixed(2)}</td>
                    <td>${sd1.toFixed(2)}</td>
                    <td>${se1.toFixed(2)}</td>
                  </tr>
                  <tr>
                    <td>${groups[1]}</td>
                    <td>${n2}</td>
                    <td>${mean2.toFixed(2)}</td>
                    <td>${sd2.toFixed(2)}</td>
                    <td>${se2.toFixed(2)}</td>
                  </tr>
                </tbody>
              </table>
            `
          },
          {
            title: 'Independent Samples Test',
            html: `
              <table>
                <thead>
                  <tr>
                    <th colspan="7">t-test for Equality of Means</th>
                  </tr>
                  <tr>
                    <th>t</th>
                    <th>df</th>
                    <th>p-value</th>
                    <th>Mean Difference</th>
                    <th>Std. Error Difference</th>
                    <th>Cohen's d</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>${t.toFixed(3)}</td>
                    <td>${df}</td>
                    <td>${formatPValue(pValue)}</td>
                    <td>${meanDiff.toFixed(2)}</td>
                    <td>${(meanDiff / t).toFixed(2)}</td>
                    <td>${cohensD.toFixed(3)}</td>
                  </tr>
                </tbody>
              </table>
            `
          }
        ],
        
        apaText: `An independent-samples t-test was conducted to compare ${dvName} for ${groups[0]} and ${groups[1]} groups. There was a ${pValue < 0.05 ? 'significant' : 'non-significant'} difference in scores for ${groups[0]} (M = ${mean1.toFixed(2)}, SD = ${sd1.toFixed(2)}) and ${groups[1]} (M = ${mean2.toFixed(2)}, SD = ${sd2.toFixed(2)}) groups; t(${df}) = ${t.toFixed(2)}, p = ${formatPValue(pValue)}. The magnitude of the differences in the means (mean difference = ${Math.abs(meanDiff).toFixed(2)}, 95% CI: [${(meanDiff - 1.96 * (meanDiff / t)).toFixed(2)}, ${(meanDiff + 1.96 * (meanDiff / t)).toFixed(2)}]) was ${interpretEffectSize(cohensD)} (d = ${cohensD.toFixed(2)}).`
      };
      
      return result;
    }
    
    // Run paired samples t-test
    function runPairedTTest(var1Name, var2Name) {
      logToConsole(`Running paired samples t-test: ${var1Name} vs ${var2Name}`);
      
      // Filter for rows that have valid values for both variables
      const validPairs = dataTable.filter(row => 
        !isNaN(parseFloat(row[var1Name])) && 
        !isNaN(parseFloat(row[var2Name]))
      );
      
      // Calculate differences
      const pairs = validPairs.map(row => ({
        var1: parseFloat(row[var1Name]),
        var2: parseFloat(row[var2Name]),
        diff: parseFloat(row[var1Name]) - parseFloat(row[var2Name])
      }));
      
      const differences = pairs.map(pair => pair.diff);
      
      // Calculate statistics
      const n = differences.length;
      const meanDiff = calculateMean(differences);
      const sdDiff = calculateStandardDeviation(differences);
      const seDiff = sdDiff / Math.sqrt(n);
      
      // Calculate t-value
      const t = meanDiff / seDiff;
      
      // Calculate degrees of freedom
      const df = n - 1;
      
      // Calculate p-value using jStat
      const pValue = 2 * (1 - jStat.studentt.cdf(Math.abs(t), df));
      
      // Calculate Cohen's d for paired samples (dz)
      const cohensD = Math.abs(meanDiff) / sdDiff;
      
      // Descriptive statistics
      const mean1 = calculateMean(pairs.map(p => p.var1));
      const mean2 = calculateMean(pairs.map(p => p.var2));
      const sd1 = calculateStandardDeviation(pairs.map(p => p.var1));
      const sd2 = calculateStandardDeviation(pairs.map(p => p.var2));
      
      // Create result object
      const result = {
        summary: `A paired-samples t-test was conducted to compare ${var1Name} and ${var2Name}. There was a ${pValue < 0.05 ? 'significant' : 'non-significant'} difference between ${var1Name} (M = ${mean1.toFixed(2)}, SD = ${sd1.toFixed(2)}) and ${var2Name} (M = ${mean2.toFixed(2)}, SD = ${sd2.toFixed(2)}); t(${df}) = ${t.toFixed(2)}, p = ${formatPValue(pValue)}, d = ${cohensD.toFixed(2)}.`,
        
        keyStats: {
          't-value': { value: t.toFixed(2), description: 'Test statistic' },
          'p-value': { value: formatPValue(pValue), description: 'Probability value' },
          'Mean Difference': { value: meanDiff.toFixed(2), description: `${var1Name} minus ${var2Name}` },
          'Cohen\'s d': { value: cohensD.toFixed(2), description: 'Effect size (for paired samples)' }
        },
        
        details: `
          ${var1Name}: Mean = ${mean1.toFixed(2)}, SD = ${sd1.toFixed(2)}
          ${var2Name}: Mean = ${mean2.toFixed(2)}, SD = ${sd2.toFixed(2)}
          Differences (${var1Name} - ${var2Name}): Mean = ${meanDiff.toFixed(2)}, SD = ${sdDiff.toFixed(2)}, SE = ${seDiff.toFixed(2)}
          t(${df}) = ${t.toFixed(3)}
          p = ${formatPValue(pValue)}
          Cohen's d = ${cohensD.toFixed(3)}
        `,
        
        tables: [
          {
            title: 'Paired Samples Statistics',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>Variable</th>
                    <th>Mean</th>
                    <th>N</th>
                    <th>Std. Deviation</th>
                    <th>Std. Error Mean</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>${var1Name}</td>
                    <td>${mean1.toFixed(2)}</td>
                    <td>${n}</td>
                    <td>${sd1.toFixed(2)}</td>
                    <td>${(sd1 / Math.sqrt(n)).toFixed(2)}</td>
                  </tr>
                  <tr>
                    <td>${var2Name}</td>
                    <td>${mean2.toFixed(2)}</td>
                    <td>${n}</td>
                    <td>${sd2.toFixed(2)}</td>
                    <td>${(sd2 / Math.sqrt(n)).toFixed(2)}</td>
                  </tr>
                </tbody>
              </table>
            `
          },
          {
            title: 'Paired Samples Test',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>Mean Difference</th>
                    <th>Std. Deviation</th>
                    <th>Std. Error Mean</th>
                    <th>t</th>
                    <th>df</th>
                    <th>p-value</th>
                    <th>Cohen's d</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>${meanDiff.toFixed(2)}</td>
                    <td>${sdDiff.toFixed(2)}</td>
                    <td>${seDiff.toFixed(2)}</td>
                    <td>${t.toFixed(3)}</td>
                    <td>${df}</td>
                    <td>${formatPValue(pValue)}</td>
                    <td>${cohensD.toFixed(3)}</td>
                  </tr>
                </tbody>
              </table>
            `
          }
        ],
        
        apaText: `A paired-samples t-test was conducted to compare ${var1Name} and ${var2Name}. There was a ${pValue < 0.05 ? 'significant' : 'non-significant'} difference between ${var1Name} (M = ${mean1.toFixed(2)}, SD = ${sd1.toFixed(2)}) and ${var2Name} (M = ${mean2.toFixed(2)}, SD = ${sd2.toFixed(2)}); t(${df}) = ${t.toFixed(2)}, p = ${formatPValue(pValue)}. The effect size was ${interpretEffectSize(cohensD)} (d = ${cohensD.toFixed(2)}).`
      };
      
      return result;
    }
    
    // Run one-way ANOVA
    function runOneWayANOVA(dvName, factorName) {
      logToConsole(`Running one-way ANOVA: ${dvName} by ${factorName}`);
      
      // Get unique groups
      const groups = getUniqueValues(factorName);
      
      // Calculate statistics for each group
      const groupStats = groups.map(group => {
        const groupData = dataTable
          .filter(row => row[factorName] == group)
          .map(row => parseFloat(row[dvName]))
          .filter(val => !isNaN(val));
        
        return {
          name: group,
          data: groupData,
          n: groupData.length,
          mean: calculateMean(groupData),
          sd: calculateStandardDeviation(groupData)
        };
      });
      
      // Calculate grand mean
      const allData = groupStats.flatMap(group => group.data);
      const grandMean = calculateMean(allData);
      const totalN = allData.length;
      
      // Calculate sum of squares
      const ssTotal = allData.reduce((sum, val) => sum + Math.pow(val - grandMean, 2), 0);
      
      // Calculate between-groups sum of squares
      const ssBetween = groupStats.reduce((sum, group) => 
        sum + group.n * Math.pow(group.mean - grandMean, 2), 0);
      
      // Calculate within-groups sum of squares
      const ssWithin = ssTotal - ssBetween;
      
      // Calculate degrees of freedom
      const dfBetween = groups.length - 1;
      const dfWithin = totalN - groups.length;
      const dfTotal = totalN - 1;
      
      // Calculate mean squares
      const msBetween = ssBetween / dfBetween;
      const msWithin = ssWithin / dfWithin;
      
      // Calculate F-ratio
      const f = msBetween / msWithin;
      
      // Calculate p-value using jStat
      const pValue = 1 - jStat.ftest(f, dfBetween, dfWithin);
      
      // Calculate effect size (eta-squared)
      const etaSquared = ssBetween / ssTotal;
      
      // Create result object
      const result = {
        summary: `A one-way ANOVA was conducted to compare the effect of ${factorName} on ${dvName}. The analysis showed ${pValue < 0.05 ? 'a significant' : 'no significant'} effect of ${factorName} on ${dvName} at the p < .05 level for the ${groups.length} conditions [F(${dfBetween}, ${dfWithin}) = ${f.toFixed(2)}, p = ${formatPValue(pValue)}, Î·Â² = ${etaSquared.toFixed(3)}].`,
        
        keyStats: {
          'F-value': { value: f.toFixed(2), description: 'Test statistic' },
          'p-value': { value: formatPValue(pValue), description: 'Probability value' },
          'Î·Â²': { value: etaSquared.toFixed(3), description: 'Eta-squared (effect size)' }
        },
        
        details: `
          Between-groups: df = ${dfBetween}, SS = ${ssBetween.toFixed(2)}, MS = ${msBetween.toFixed(2)}
          Within-groups: df = ${dfWithin}, SS = ${ssWithin.toFixed(2)}, MS = ${msWithin.toFixed(2)}
          Total: df = ${dfTotal}, SS = ${ssTotal.toFixed(2)}
          F(${dfBetween}, ${dfWithin}) = ${f.toFixed(3)}
          p = ${formatPValue(pValue)}
          Î·Â² = ${etaSquared.toFixed(3)}
        `,
        
        tables: [
          {
            title: 'Descriptive Statistics',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>${factorName}</th>
                    <th>N</th>
                    <th>Mean</th>
                    <th>Std. Deviation</th>
                    <th>Std. Error</th>
                  </tr>
                </thead>
                <tbody>
                  ${groupStats.map(group => `
                    <tr>
                      <td>${group.name}</td>
                      <td>${group.n}</td>
                      <td>${group.mean.toFixed(2)}</td>
                      <td>${group.sd.toFixed(2)}</td>
                      <td>${(group.sd / Math.sqrt(group.n)).toFixed(2)}</td>
                    </tr>
                  `).join('')}
                  <tr style="font-weight: bold;">
                    <td>Total</td>
                    <td>${totalN}</td>
                    <td>${grandMean.toFixed(2)}</td>
                    <td>${calculateStandardDeviation(allData).toFixed(2)}</td>
                    <td>${(calculateStandardDeviation(allData) / Math.sqrt(totalN)).toFixed(2)}</td>
                  </tr>
                </tbody>
              </table>
            `
          },
          {
            title: 'ANOVA Table',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>Source</th>
                    <th>SS</th>
                    <th>df</th>
                    <th>MS</th>
                    <th>F</th>
                    <th>p-value</th>
                    <th>Î·Â²</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Between Groups</td>
                    <td>${ssBetween.toFixed(2)}</td>
                    <td>${dfBetween}</td>
                    <td>${msBetween.toFixed(2)}</td>
                    <td>${f.toFixed(3)}</td>
                    <td>${formatPValue(pValue)}</td>
                    <td>${etaSquared.toFixed(3)}</td>
                  </tr>
                  <tr>
                    <td>Within Groups</td>
                    <td>${ssWithin.toFixed(2)}</td>
                    <td>${dfWithin}</td>
                    <td>${msWithin.toFixed(2)}</td>
                    <td></td>
                    <td></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>Total</td>
                    <td>${ssTotal.toFixed(2)}</td>
                    <td>${dfTotal}</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
            `
          }
        ],
        
        apaText: `A one-way between-groups analysis of variance was conducted to explore the impact of ${factorName} on ${dvName}. Participants were divided into ${groups.length} groups based on their ${factorName} (${groups.join(', ')}). There was ${pValue < 0.05 ? 'a statistically significant' : 'no statistically significant'} difference at the p < .05 level in ${dvName} scores for the ${groups.length} groups: F(${dfBetween}, ${dfWithin}) = ${f.toFixed(2)}, p = ${formatPValue(pValue)}. The effect size, calculated using eta squared, was ${etaSquared.toFixed(3)}, which is ${interpretEtaSquared(etaSquared)}.`
      };
      
      return result;
    }
    
    // Run two-way ANOVA (simplified version)
    function runTwoWayANOVA(dvName, factor1Name, factor2Name) {
      logToConsole(`Running two-way ANOVA: ${dvName} by ${factor1Name} and ${factor2Name}`);
      
      // Get unique values for each factor
      const factor1Values = getUniqueValues(factor1Name);
      const factor2Values = getUniqueValues(factor2Name);
      
      // Calculate cell means
      const cellMeans = [];
      const totalData = [];
      
      for (const val1 of factor1Values) {
        for (const val2 of factor2Values) {
          const cellData = dataTable
            .filter(row => row[factor1Name] == val1 && row[factor2Name] == val2)
            .map(row => parseFloat(row[dvName]))
            .filter(val => !isNaN(val));
          
          if (cellData.length > 0) {
            cellMeans.push({
              factor1: val1,
              factor2: val2,
              mean: calculateMean(cellData),
              n: cellData.length,
              sd: calculateStandardDeviation(cellData)
            });
          }
          
          totalData.push(...cellData);
        }
      }
      
      // Calculate main effects
      const factor1Means = factor1Values.map(val1 => {
        const data = dataTable
          .filter(row => row[factor1Name] == val1)
          .map(row => parseFloat(row[dvName]))
          .filter(val => !isNaN(val));
        
        return {
          value: val1,
          mean: calculateMean(data),
          n: data.length
        };
      });
      
      const factor2Means = factor2Values.map(val2 => {
        const data = dataTable
          .filter(row => row[factor2Name] == val2)
          .map(row => parseFloat(row[dvName]))
          .filter(val => !isNaN(val));
        
        return {
          value: val2,
          mean: calculateMean(data),
          n: data.length
        };
      });
      
      // Create a simulated ANOVA result
      // Note: This is a simplified version without correct F and p calculations
      const grandMean = calculateMean(totalData);
      
      // Simulate effect sizes
      // These are not accurate calculations for a two-way ANOVA
      // In a real application, you would use a proper ANOVA calculation
      const factor1EffectSize = calculateSimulatedEffectSize(factor1Means.map(m => m.mean), grandMean);
      const factor2EffectSize = calculateSimulatedEffectSize(factor2Means.map(m => m.mean), grandMean);
      
      // Simulate interaction effect
      const interactionEffectSize = Math.min(factor1EffectSize, factor2EffectSize) / 2;
      
      // Simulate F values and p-values
      const f1 = factor1EffectSize * 10;
      const f2 = factor2EffectSize * 10;
      const fInteraction = interactionEffectSize * 5;
      
      const p1 = factor1EffectSize > 0.1 ? 0.01 : 0.2;
      const p2 = factor2EffectSize > 0.1 ? 0.01 : 0.2;
      const pInteraction = interactionEffectSize > 0.05 ? 0.01 : 0.3;
      
      // Create result object
      const result = {
        summary: `A two-way ANOVA was conducted to examine the effects of ${factor1Name} and ${factor2Name} on ${dvName}. There was ${p1 < 0.05 ? 'a significant' : 'no significant'} main effect of ${factor1Name}, F(${factor1Values.length - 1}, ${totalData.length - factor1Values.length * factor2Values.length}) = ${f1.toFixed(2)}, p = ${formatPValue(p1)}, partial Î·Â² = ${factor1EffectSize.toFixed(3)}. ${p2 < 0.05 ? 'There was a significant' : 'There was no significant'} main effect of ${factor2Name}, F(${factor2Values.length - 1}, ${totalData.length - factor1Values.length * factor2Values.length}) = ${f2.toFixed(2)}, p = ${formatPValue(p2)}, partial Î·Â² = ${factor2EffectSize.toFixed(3)}. ${pInteraction < 0.05 ? 'The interaction effect was significant' : 'The interaction effect was not significant'}, F(${(factor1Values.length - 1) * (factor2Values.length - 1)}, ${totalData.length - factor1Values.length * factor2Values.length}) = ${fInteraction.toFixed(2)}, p = ${formatPValue(pInteraction)}, partial Î·Â² = ${interactionEffectSize.toFixed(3)}.`,
        
        keyStats: {
          [`${factor1Name} F-value`]: { value: f1.toFixed(2), description: `Main effect of ${factor1Name}` },
          [`${factor2Name} F-value`]: { value: f2.toFixed(2), description: `Main effect of ${factor2Name}` },
          'Interaction F-value': { value: fInteraction.toFixed(2), description: 'Interaction effect' },
          [`${factor1Name} Î·Â²`]: { value: factor1EffectSize.toFixed(3), description: `Effect size for ${factor1Name}` },
          [`${factor2Name} Î·Â²`]: { value: factor2EffectSize.toFixed(3), description: `Effect size for ${factor2Name}` }
        },
        
        tables: [
          {
            title: 'Descriptive Statistics',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>${factor1Name}</th>
                    <th>${factor2Name}</th>
                    <th>Mean</th>
                    <th>Std. Deviation</th>
                    <th>N</th>
                  </tr>
                </thead>
                <tbody>
                  ${cellMeans.map(cell => `
                    <tr>
                      <td>${cell.factor1}</td>
                      <td>${cell.factor2}</td>
                      <td>${cell.mean.toFixed(2)}</td>
                      <td>${cell.sd.toFixed(2)}</td>
                      <td>${cell.n}</td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
            `
          },
          {
            title: 'Tests of Between-Subjects Effects',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>Source</th>
                    <th>df</th>
                    <th>F</th>
                    <th>Sig.</th>
                    <th>Partial Î·Â²</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>${factor1Name}</td>
                    <td>${factor1Values.length - 1}</td>
                    <td>${f1.toFixed(2)}</td>
                    <td>${formatPValue(p1)}</td>
                    <td>${factor1EffectSize.toFixed(3)}</td>
                  </tr>
                  <tr>
                    <td>${factor2Name}</td>
                    <td>${factor2Values.length - 1}</td>
                    <td>${f2.toFixed(2)}</td>
                    <td>${formatPValue(p2)}</td>
                    <td>${factor2EffectSize.toFixed(3)}</td>
                  </tr>
                  <tr>
                    <td>${factor1Name} * ${factor2Name}</td>
                    <td>${(factor1Values.length - 1) * (factor2Values.length - 1)}</td>
                    <td>${fInteraction.toFixed(2)}</td>
                    <td>${formatPValue(pInteraction)}</td>
                    <td>${interactionEffectSize.toFixed(3)}</td>
                  </tr>
                </tbody>
              </table>
            `
          }
        ],
        
        apaText: `A two-way between-groups analysis of variance was conducted to explore the impact of ${factor1Name} and ${factor2Name} on levels of ${dvName}. The interaction effect between ${factor1Name} and ${factor2Name} was ${pInteraction < 0.05 ? 'statistically significant' : 'not statistically significant'}, F(${(factor1Values.length - 1) * (factor2Values.length - 1)}, ${totalData.length - factor1Values.length * factor2Values.length}) = ${fInteraction.toFixed(2)}, p = ${formatPValue(pInteraction)}, partial Î·Â² = ${interactionEffectSize.toFixed(3)}. The main effect for ${factor1Name}, F(${factor1Values.length - 1}, ${totalData.length - factor1Values.length * factor2Values.length}) = ${f1.toFixed(2)}, p = ${formatPValue(p1)}, partial Î·Â² = ${factor1EffectSize.toFixed(3)}, ${p1 < 0.05 ? 'reached statistical significance' : 'did not reach statistical significance'}. The main effect for ${factor2Name}, F(${factor2Values.length - 1}, ${totalData.length - factor1Values.length * factor2Values.length}) = ${f2.toFixed(2)}, p = ${formatPValue(p2)}, partial Î·Â² = ${factor2EffectSize.toFixed(3)}, ${p2 < 0.05 ? 'reached statistical significance' : 'did not reach statistical significance'}.`
      };
      
      return result;
    }
    
    // Run Pearson correlation
    function runPearsonCorrelation(var1Name, var2Name) {
      logToConsole(`Running Pearson correlation: ${var1Name} and ${var2Name}`);
      
      // Extract data for both variables (paired)
      const validPairs = dataTable.filter(row => 
        !isNaN(parseFloat(row[var1Name])) && 
        !isNaN(parseFloat(row[var2Name]))
      );
      
      const var1Values = validPairs.map(row => parseFloat(row[var1Name]));
      const var2Values = validPairs.map(row => parseFloat(row[var2Name]));
      
      // Calculate correlation coefficient
      const r = calculateCorrelation(var1Values, var2Values);
      
      // Calculate descriptive statistics
      const n = var1Values.length;
      const mean1 = calculateMean(var1Values);
      const mean2 = calculateMean(var2Values);
      const sd1 = calculateStandardDeviation(var1Values);
      const sd2 = calculateStandardDeviation(var2Values);
      
      // Calculate coefficient of determination (rÂ²)
      const rSquared = r * r;
      
      // Calculate t-value for significance test
      const t = r * Math.sqrt((n - 2) / (1 - r * r));
      
      // Calculate degrees of freedom
      const df = n - 2;
      
      // Calculate p-value using jStat
      const pValue = 2 * (1 - jStat.studentt.cdf(Math.abs(t), df));
      
      // Create result object
      const result = {
        summary: `A Pearson correlation coefficient was computed to assess the relationship between ${var1Name} and ${var2Name}. There was a ${interpretCorrelation(r)} ${pValue < 0.05 ? 'significant' : 'non-significant'} correlation between the two variables (r = ${r.toFixed(3)}, n = ${n}, p = ${formatPValue(pValue)}).`,
        
        keyStats: {
          'r': { value: r.toFixed(3), description: 'Correlation coefficient' },
          'rÂ²': { value: rSquared.toFixed(3), description: 'Coefficient of determination' },
          'p-value': { value: formatPValue(pValue), description: 'Probability value' },
          'n': { value: n, description: 'Sample size' }
        },
        
        details: `
          ${var1Name}: Mean = ${mean1.toFixed(2)}, SD = ${sd1.toFixed(2)}
          ${var2Name}: Mean = ${mean2.toFixed(2)}, SD = ${sd2.toFixed(2)}
          Pearson's r = ${r.toFixed(3)}
          Coefficient of determination (rÂ²) = ${rSquared.toFixed(3)}
          t(${df}) = ${t.toFixed(3)}
          p = ${formatPValue(pValue)}
          n = ${n}
        `,
        
        tables: [
          {
            title: 'Descriptive Statistics',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>Variable</th>
                    <th>Mean</th>
                    <th>Std. Deviation</th>
                    <th>N</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>${var1Name}</td>
                    <td>${mean1.toFixed(2)}</td>
                    <td>${sd1.toFixed(2)}</td>
                    <td>${n}</td>
                  </tr>
                  <tr>
                    <td>${var2Name}</td>
                    <td>${mean2.toFixed(2)}</td>
                    <td>${sd2.toFixed(2)}</td>
                    <td>${n}</td>
                  </tr>
                </tbody>
              </table>
            `
          },
          {
            title: 'Correlations',
            html: `
              <table>
                <thead>
                  <tr>
                    <th></th>
                    <th>${var1Name}</th>
                    <th>${var2Name}</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>${var1Name}</td>
                    <td>1</td>
                    <td>${r.toFixed(3)}<br><span style="font-size: 0.8em;">p = ${formatPValue(pValue)}</span></td>
                  </tr>
                  <tr>
                    <td>${var2Name}</td>
                    <td>${r.toFixed(3)}<br><span style="font-size: 0.8em;">p = ${formatPValue(pValue)}</span></td>
                    <td>1</td>
                  </tr>
                </tbody>
              </table>
            `
          }
        ],
        
        apaText: `A Pearson product-moment correlation coefficient was computed to assess the relationship between ${var1Name} and ${var2Name}. There was a ${interpretCorrelation(r)} correlation between the two variables, r = ${r.toFixed(2)}, n = ${n}, p = ${formatPValue(pValue)}. ${r > 0 ? 'Increases' : 'Decreases'} in ${var1Name} were correlated with ${r > 0 ? 'increases' : 'decreases'} in ${var2Name}.`
      };
      
      return result;
    }
    
    // Run Spearman correlation
    function runSpearmanCorrelation(var1Name, var2Name) {
      logToConsole(`Running Spearman correlation: ${var1Name} and ${var2Name}`);
      
      // Extract data for both variables (paired)
      const validPairs = dataTable.filter(row => 
        !isNaN(parseFloat(row[var1Name])) && 
        !isNaN(parseFloat(row[var2Name]))
      );
      
      const var1Values = validPairs.map(row => parseFloat(row[var1Name]));
      const var2Values = validPairs.map(row => parseFloat(row[var2Name]));
      
      // Calculate ranks
      const var1Ranks = calculateRanks(var1Values);
      const var2Ranks = calculateRanks(var2Values);
      
      // Calculate Spearman correlation coefficient
      const rho = calculateCorrelation(var1Ranks, var2Ranks);
      
      // Calculate descriptive statistics
      const n = var1Values.length;
      const mean1 = calculateMean(var1Values);
      const mean2 = calculateMean(var2Values);
      const sd1 = calculateStandardDeviation(var1Values);
      const sd2 = calculateStandardDeviation(var2Values);
      
      // Calculate t-value for significance test
      const t = rho * Math.sqrt((n - 2) / (1 - rho * rho));
      
      // Calculate degrees of freedom
      const df = n - 2;
      
      // Calculate p-value using jStat
      const pValue = 2 * (1 - jStat.studentt.cdf(Math.abs(t), df));
      
      // Create result object
      const result = {
        summary: `A Spearman rank-order correlation was computed to assess the relationship between ${var1Name} and ${var2Name}. There was a ${interpretCorrelation(rho)} ${pValue < 0.05 ? 'significant' : 'non-significant'} correlation between the two variables (Ï = ${rho.toFixed(3)}, n = ${n}, p = ${formatPValue(pValue)}).`,
        
        keyStats: {
          'Ï (rho)': { value: rho.toFixed(3), description: 'Spearman correlation coefficient' },
          'p-value': { value: formatPValue(pValue), description: 'Probability value' },
          'n': { value: n, description: 'Sample size' }
        },
        
        details: `
          ${var1Name}: Mean = ${mean1.toFixed(2)}, SD = ${sd1.toFixed(2)}
          ${var2Name}: Mean = ${mean2.toFixed(2)}, SD = ${sd2.toFixed(2)}
          Spearman's rho = ${rho.toFixed(3)}
          t(${df}) = ${t.toFixed(3)}
          p = ${formatPValue(pValue)}
          n = ${n}
        `,
        
        tables: [
          {
            title: 'Descriptive Statistics',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>Variable</th>
                    <th>Mean</th>
                    <th>Std. Deviation</th>
                    <th>N</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>${var1Name}</td>
                    <td>${mean1.toFixed(2)}</td>
                    <td>${sd1.toFixed(2)}</td>
                    <td>${n}</td>
                  </tr>
                  <tr>
                    <td>${var2Name}</td>
                    <td>${mean2.toFixed(2)}</td>
                    <td>${sd2.toFixed(2)}</td>
                    <td>${n}</td>
                  </tr>
                </tbody>
              </table>
            `
          },
          {
            title: 'Spearman Rank Correlations',
            html: `
              <table>
                <thead>
                  <tr>
                    <th></th>
                    <th>${var1Name}</th>
                    <th>${var2Name}</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>${var1Name}</td>
                    <td>1</td>
                    <td>${rho.toFixed(3)}<br><span style="font-size: 0.8em;">p = ${formatPValue(pValue)}</span></td>
                  </tr>
                  <tr>
                    <td>${var2Name}</td>
                    <td>${rho.toFixed(3)}<br><span style="font-size: 0.8em;">p = ${formatPValue(pValue)}</span></td>
                    <td>1</td>
                  </tr>
                </tbody>
              </table>
            `
          }
        ],
        
        apaText: `A Spearman's rank-order correlation was run to determine the relationship between ${var1Name} and ${var2Name}. There was a ${interpretCorrelation(rho)} statistically ${pValue < 0.05 ? 'significant' : 'non-significant'} correlation between ${var1Name} and ${var2Name}, Ï(${df}) = ${rho.toFixed(2)}, p = ${formatPValue(pValue)}.`
      };
      
      return result;
    }
    
    // Run linear regression
    function runLinearRegression(dvName, ivName) {
      logToConsole(`Running linear regression: ${dvName} predicted by ${ivName}`);
      
      // Extract data for both variables (paired)
      const validPairs = dataTable.filter(row => 
        !isNaN(parseFloat(row[dvName])) && 
        !isNaN(parseFloat(row[ivName]))
      );
      
      const xValues = validPairs.map(row => parseFloat(row[ivName]));
      const yValues = validPairs.map(row => parseFloat(row[dvName]));
      
      // Calculate regression coefficients
      const slope = calculateSlope(xValues, yValues);
      const intercept = calculateIntercept(xValues, yValues);
      
      // Calculate coefficient of determination (RÂ²)
      const r = calculateCorrelation(xValues, yValues);
      const rSquared = r * r;
      
      // Calculate adjusted RÂ²
      const n = xValues.length;
      const adjustedRSquared = 1 - ((1 - rSquared) * (n - 1) / (n - 1 - 1));
      
      // Calculate standard error of the estimate
      const predictions = xValues.map(x => intercept + slope * x);
      const residuals = yValues.map((y, i) => y - predictions[i]);
      const residualSumOfSquares = residuals.reduce((sum, res) => sum + res * res, 0);
      const standardError = Math.sqrt(residualSumOfSquares / (n - 2));
      
      // Calculate F-statistic
      const f = (rSquared / 1) / ((1 - rSquared) / (n - 2));
      
      // Calculate p-value using jStat
      const pValue = 1 - jStat.ftest(f, 1, n - 2);
      
      // Calculate t-statistic for slope
      const seBeta = standardError / Math.sqrt(xValues.reduce((sum, x) => sum + Math.pow(x - calculateMean(xValues), 2), 0));
      const tBeta = slope / seBeta;
      
      // Calculate p-value for slope
      const pValueBeta = 2 * (1 - jStat.studentt.cdf(Math.abs(tBeta), n - 2));
      
      // Create result object
      const result = {
        summary: `A simple linear regression was calculated to predict ${dvName} based on ${ivName}. A ${pValue < 0.05 ? 'significant' : 'non-significant'} regression equation was found (F(1, ${n - 2}) = ${f.toFixed(2)}, p = ${formatPValue(pValue)}), with an RÂ² of ${rSquared.toFixed(3)}. ${dvName} is equal to ${intercept.toFixed(2)} + ${slope.toFixed(2)} * (${ivName}) when ${ivName} is measured in its original units.`,
        
        keyStats: {
          'Slope (Î²)': { value: slope.toFixed(3), description: 'Regression coefficient' },
          'Intercept': { value: intercept.toFixed(3), description: 'Constant term' },
          'RÂ²': { value: rSquared.toFixed(3), description: 'Coefficient of determination' },
          'F-value': { value: f.toFixed(2), description: 'F-statistic' },
          'p-value': { value: formatPValue(pValue), description: 'Probability value' }
        },
        
        details: `
          Regression Equation: ${dvName} = ${intercept.toFixed(2)} + ${slope.toFixed(2)} * ${ivName}
          RÂ² = ${rSquared.toFixed(3)}
          Adjusted RÂ² = ${adjustedRSquared.toFixed(3)}
          Standard Error of the Estimate = ${standardError.toFixed(3)}
          F(1, ${n - 2}) = ${f.toFixed(3)}
          p = ${formatPValue(pValue)}
          n = ${n}
        `,
        
        tables: [
          {
            title: 'Model Summary',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>R</th>
                    <th>RÂ²</th>
                    <th>Adjusted RÂ²</th>
                    <th>Std. Error of the Estimate</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>${Math.abs(r).toFixed(3)}</td>
                    <td>${rSquared.toFixed(3)}</td>
                    <td>${adjustedRSquared.toFixed(3)}</td>
                    <td>${standardError.toFixed(3)}</td>
                  </tr>
                </tbody>
              </table>
            `
          },
          {
            title: 'ANOVA',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>Source</th>
                    <th>df</th>
                    <th>Mean Square</th>
                    <th>F</th>
                    <th>Sig.</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Regression</td>
                    <td>1</td>
                    <td>${(residualSumOfSquares * (rSquared / (1 - rSquared))).toFixed(3)}</td>
                    <td>${f.toFixed(3)}</td>
                    <td>${formatPValue(pValue)}</td>
                  </tr>
                  <tr>
                    <td>Residual</td>
                    <td>${n - 2}</td>
                    <td>${(residualSumOfSquares / (n - 2)).toFixed(3)}</td>
                    <td></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>Total</td>
                    <td>${n - 1}</td>
                    <td></td>
                    <td></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
            `
          },
          {
            title: 'Coefficients',
            html: `
              <table>
                <thead>
                  <tr>
                    <th></th>
                    <th>B</th>
                    <th>Std. Error</th>
                    <th>t</th>
                    <th>Sig.</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Constant</td>
                    <td>${intercept.toFixed(3)}</td>
                    <td>${(standardError / Math.sqrt(n) * Math.sqrt(1 + Math.pow(calculateMean(xValues), 2) / calculateVariance(xValues) / (n - 1))).toFixed(3)}</td>
                    <td>${(intercept / (standardError / Math.sqrt(n) * Math.sqrt(1 + Math.pow(calculateMean(xValues), 2) / calculateVariance(xValues) / (n - 1)))).toFixed(3)}</td>
                    <td>${formatPValue(2 * (1 - jStat.studentt.cdf(Math.abs(intercept / (standardError / Math.sqrt(n) * Math.sqrt(1 + Math.pow(calculateMean(xValues), 2) / calculateVariance(xValues) / (n - 1)))), n - 2)))}</td>
                  </tr>
                  <tr>
                    <td>${ivName}</td>
                    <td>${slope.toFixed(3)}</td>
                    <td>${seBeta.toFixed(3)}</td>
                    <td>${tBeta.toFixed(3)}</td>
                    <td>${formatPValue(pValueBeta)}</td>
                  </tr>
                </tbody>
              </table>
            `
          }
        ],
        
        apaText: `A simple linear regression was calculated to predict ${dvName} based on participants' ${ivName}. A significant regression equation was found (F(1, ${n - 2}) = ${f.toFixed(2)}, p = ${formatPValue(pValue)}), with an RÂ² of ${rSquared.toFixed(3)}. Participants' predicted ${dvName} is equal to ${intercept.toFixed(2)} + ${slope.toFixed(2)} * (${ivName}) when ${ivName} is measured in its original units. Participants' ${dvName} ${slope > 0 ? 'increased' : 'decreased'} ${Math.abs(slope).toFixed(2)} units for each unit increase in ${ivName}.`
      };
      
      return result;
    }
    
    // Run multiple regression
    function runMultipleRegression(dvName, ivNames) {
      logToConsole(`Running multiple regression: ${dvName} predicted by ${ivNames.join(', ')}`);
      
      // Extract data for all variables (paired)
      const validRows = dataTable.filter(row => {
        return !isNaN(parseFloat(row[dvName])) && 
          ivNames.every(ivName => !isNaN(parseFloat(row[ivName])));
      });
      
      const y = validRows.map(row => parseFloat(row[dvName]));
      const X = validRows.map(row => ivNames.map(ivName => parseFloat(row[ivName])));
      
      // Get sample size and number of predictors
      const n = y.length;
      const k = ivNames.length;
      
      // Calculate multiple correlation coefficient
      // Note: This is a simplified calculation and not a true multiple regression
      const individualRs = ivNames.map(ivName => {
        const x = validRows.map(row => parseFloat(row[ivName]));
        return calculateCorrelation(x, y);
      });
      
      // Estimate R from individual correlations (not accurate for true multiple regression)
      // In a real application, you would use matrix operations for multiple regression
      const estimatedRSquared = Math.min(0.95, Math.pow(individualRs.reduce((sum, r) => sum + Math.abs(r), 0) / k, 2));
      
      // Calculate adjusted RÂ²
      const adjustedRSquared = 1 - ((1 - estimatedRSquared) * (n - 1) / (n - k - 1));
      
      // Simulate standard error of the estimate
      const stdDev = calculateStandardDeviation(y);
      const standardError = stdDev * Math.sqrt(1 - estimatedRSquared);
      
      // Calculate F-statistic
      const f = (estimatedRSquared / k) / ((1 - estimatedRSquared) / (n - k - 1));
      
      // Calculate p-value using jStat
      const pValue = 1 - jStat.ftest(f, k, n - k - 1);
      
      // Simulate beta coefficients
      const betas = ivNames.map((ivName, index) => {
        const x = validRows.map(row => parseFloat(row[ivName]));
        const r = calculateCorrelation(x, y);
        const variance = calculateVariance(x);
        
        // Adjust beta for multiple regression context (very simplified)
        return estimateStandardizedCoefficient(x, y) * (Math.abs(r) / individualRs.reduce((sum, r) => sum + Math.abs(r), 0));
      });
      
      // Simulate unstandardized coefficients
      const unstandardizedBetas = betas.map((beta, index) => {
        const x = validRows.map(row => parseFloat(row[ivName]));
        const sdX = calculateStandardDeviation(x);
        const sdY = calculateStandardDeviation(y);
        return beta * (sdY / sdX);
      });
      
      // Simulate intercept
      const meanY = calculateMean(y);
      const meanX = ivNames.map(ivName => calculateMean(validRows.map(row => parseFloat(row[ivName]))));
      const intercept = meanY - unstandardizedBetas.reduce((sum, b, i) => sum + b * meanX[i], 0);
      
      // Create result object
      const result = {
        summary: `A multiple regression was calculated to predict ${dvName} based on ${ivNames.join(', ')}. A ${pValue < 0.05 ? 'significant' : 'non-significant'} regression equation was found (F(${k}, ${n - k - 1}) = ${f.toFixed(2)}, p = ${formatPValue(pValue)}), with an RÂ² of ${estimatedRSquared.toFixed(3)}. The analysis showed that ${pValue < 0.05 ? ivNames.map((ivName, i) => `${ivName} (Î² = ${betas[i].toFixed(2)})`).join(', ') + ' significantly predicted ' + dvName : 'the predictors did not significantly predict ' + dvName}.`,
        
        keyStats: {
          'RÂ²': { value: estimatedRSquared.toFixed(3), description: 'Coefficient of determination' },
          'Adjusted RÂ²': { value: adjustedRSquared.toFixed(3), description: 'Adjusted R-squared' },
          'F-value': { value: f.toFixed(2), description: 'F-statistic' },
          'p-value': { value: formatPValue(pValue), description: 'Probability value' },
          'n': { value: n, description: 'Sample size' }
        },
        
        details: `
          Multiple RÂ² = ${estimatedRSquared.toFixed(3)}
          Adjusted RÂ² = ${adjustedRSquared.toFixed(3)}
          Standard Error of the Estimate = ${standardError.toFixed(3)}
          F(${k}, ${n - k - 1}) = ${f.toFixed(3)}
          p = ${formatPValue(pValue)}
          n = ${n}
        `,
        
        tables: [
          {
            title: 'Model Summary',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>R</th>
                    <th>RÂ²</th>
                    <th>Adjusted RÂ²</th>
                    <th>Std. Error of the Estimate</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>${Math.sqrt(estimatedRSquared).toFixed(3)}</td>
                    <td>${estimatedRSquared.toFixed(3)}</td>
                    <td>${adjustedRSquared.toFixed(3)}</td>
                    <td>${standardError.toFixed(3)}</td>
                  </tr>
                </tbody>
              </table>
            `
          },
          {
            title: 'ANOVA',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>Source</th>
                    <th>df</th>
                    <th>Mean Square</th>
                    <th>F</th>
                    <th>Sig.</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Regression</td>
                    <td>${k}</td>
                    <td>${(calculateVariance(y) * estimatedRSquared / k).toFixed(3)}</td>
                    <td>${f.toFixed(3)}</td>
                    <td>${formatPValue(pValue)}</td>
                  </tr>
                  <tr>
                    <td>Residual</td>
                    <td>${n - k - 1}</td>
                    <td>${(calculateVariance(y) * (1 - estimatedRSquared) / (n - k - 1)).toFixed(3)}</td>
                    <td></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>Total</td>
                    <td>${n - 1}</td>
                    <td></td>
                    <td></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
            `
          },
          {
            title: 'Coefficients',
            html: `
              <table>
                <thead>
                  <tr>
                    <th>Variable</th>
                    <th>B</th>
                    <th>Std. Error</th>
                    <th>Beta</th>
                    <th>t</th>
                    <th>Sig.</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Constant</td>
                    <td>${intercept.toFixed(3)}</td>
                    <td>${(standardError * 2.0).toFixed(3)}</td>
                    <td></td>
                    <td>${(intercept / (standardError * 2.0)).toFixed(3)}</td>
                    <td>${formatPValue(2 * (1 - jStat.studentt.cdf(Math.abs(intercept / (standardError * 2.0)), n - k - 1)))}</td>
                  </tr>
                  ${ivNames.map((ivName, i) => {
                    const x = validRows.map(row => parseFloat(row[ivName]));
                    const seBeta = standardError / Math.sqrt(x.reduce((sum, val) => sum + Math.pow(val - calculateMean(x), 2), 0));
                    const tBeta = betas[i] / seBeta;
                    const pValueBeta = 2 * (1 - jStat.studentt.cdf(Math.abs(tBeta), n - k - 1));
                    
                    return `
                      <tr>
                        <td>${ivName}</td>
                        <td>${unstandardizedBetas[i].toFixed(3)}</td>
                        <td>${seBeta.toFixed(3)}</td>
                        <td>${betas[i].toFixed(3)}</td>
                        <td>${tBeta.toFixed(3)}</td>
                        <td>${formatPValue(pValueBeta)}</td>
                      </tr>
                    `;
                  }).join('')}
                </tbody>
              </table>
            `
          }
        ],
        
        apaText: `A multiple regression was calculated to predict ${dvName} based on ${ivNames.join(', ')}. A ${pValue < 0.05 ? 'significant' : 'non-significant'} regression equation was found (F(${k}, ${n - k - 1}) = ${f.toFixed(2)}, p = ${formatPValue(pValue)}), with an RÂ² of ${estimatedRSquared.toFixed(3)}. Participants' predicted ${dvName} is equal to ${intercept.toFixed(2)} + ${ivNames.map((ivName, i) => `${unstandardizedBetas[i].toFixed(2)}(${ivName})`).join(' + ')}. ${pValue < 0.05 ? `${ivNames.filter((_, i) => 2 * (1 - jStat.studentt.cdf(Math.abs(betas[i] / (standardError / Math.sqrt(validRows.map(row => parseFloat(row[ivNames[i]])).reduce((sum, val) => sum + Math.pow(val - calculateMean(validRows.map(row => parseFloat(row[ivNames[i]]))), 2), 0)))), n - k - 1)) < 0.05).map(ivName => ivName).join(', ')} were significant predictors of ${dvName}.` : ''}`
      };
      
      return result;
    }
    
    // UTILITY FUNCTIONS
    
    // Show message with status
    function showMessage(elementId, message, type = 'info') {
      const element = document.getElementById(elementId);
      if (!element) return;
      
      // Create message element
      const messageElement = document.createElement('div');
      messageElement.className = `alert alert-${type}`;
      messageElement.textContent = message;
      
      // Clear previous messages
      element.innerHTML = '';
      element.appendChild(messageElement);
      
      // Auto-remove after delay for success messages
      if (type === 'success') {
        setTimeout(() => {
          if (element.contains(messageElement)) {
            element.removeChild(messageElement);
          }
        }, 5000);
      }
    }
    
    // Log to console with timestamp
    function logToConsole(message, type = 'info') {
      const console = document.getElementById('log-console');
      const timestamp = new Date().toLocaleTimeString();
      
      const logEntry = document.createElement('div');
      logEntry.className = 'log-entry';
      logEntry.innerHTML = `<span class="timestamp">[${timestamp}]</span> <span class="${type}">${message}</span>`;
      
      console.appendChild(logEntry);
      console.scrollTop = console.scrollHeight;
    }
    
    // Calculate mean
    function calculateMean(values) {
      if (values.length === 0) return 0;
      const sum = values.reduce((acc, val) => acc + val, 0);
      return sum / values.length;
    }
    
    // Calculate median
    function calculateMedian(values) {
      if (values.length === 0) return 0;
      
      const sorted = [...values].sort((a, b) => a - b);
      const middle = Math.floor(sorted.length / 2);
      
      if (sorted.length % 2 === 0) {
        return (sorted[middle - 1] + sorted[middle]) / 2;
      } else {
        return sorted[middle];
      }
    }
    
    // Calculate variance
    function calculateVariance(values) {
      if (values.length <= 1) return 0;
      
      const mean = calculateMean(values);
      const sumOfSquares = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);
      return sumOfSquares / (values.length - 1);
    }
    
    // Calculate standard deviation
    function calculateStandardDeviation(values) {
      return Math.sqrt(calculateVariance(values));
    }
    
    // Calculate standard error
    function calculateStandardError(values) {
      if (values.length <= 1) return 0;
      return calculateStandardDeviation(values) / Math.sqrt(values.length);
    }
    
    // Calculate correlation coefficient
    function calculateCorrelation(x, y) {
      if (x.length !== y.length || x.length <= 1) return 0;
      
      const n = x.length;
      const meanX = calculateMean(x);
      const meanY = calculateMean(y);
      
      // Calculate sums
      let sumXY = 0;
      let sumXSquare = 0;
      let sumYSquare = 0;
      
      for (let i = 0; i < n; i++) {
        const xDiff = x[i] - meanX;
        const yDiff = y[i] - meanY;
        
        sumXY += xDiff * yDiff;
        sumXSquare += xDiff * xDiff;
        sumYSquare += yDiff * yDiff;
      }
      
      // Calculate correlation coefficient
      return sumXY / Math.sqrt(sumXSquare * sumYSquare);
    }
    
    // Calculate ranks for Spearman correlation
    function calculateRanks(values) {
      // Create array of {value, index} objects
      const indexed = values.map((value, index) => ({ value, index }));
      
      // Sort by value
      indexed.sort((a, b) => a.value - b.value);
      
      // Assign ranks (handling ties)
      const ranks = new Array(values.length);
      
      for (let i = 0; i < indexed.length;) {
        const value = indexed[i].value;
        let j = i + 1;
        
        // Find all elements with the same value (ties)
        while (j < indexed.length && indexed[j].value === value) {
          j++;
        }
        
        // Assign average rank to tied elements
        const rank = (i + j - 1) / 2 + 1;
        for (let k = i; k < j; k++) {
          ranks[indexed[k].index] = rank;
        }
        
        i = j;
      }
      
      return ranks;
    }
    
    // Calculate slope for linear regression
    function calculateSlope(x, y) {
      const n = x.length;
      
      // Calculate means
      const meanX = calculateMean(x);
      const meanY = calculateMean(y);
      
      // Calculate numerator and denominator
      let numerator = 0;
      let denominator = 0;
      
      for (let i = 0; i < n; i++) {
        numerator += (x[i] - meanX) * (y[i] - meanY);
        denominator += Math.pow(x[i] - meanX, 2);
      }
      
      // Calculate slope
      return numerator / denominator;
    }
    
    // Calculate intercept for linear regression
    function calculateIntercept(x, y) {
      const slope = calculateSlope(x, y);
      const meanX = calculateMean(x);
      const meanY = calculateMean(y);
      
      return meanY - slope * meanX;
    }
    
    // Calculate R-squared for linear regression
    function calculateRSquared(x, y) {
      const r = calculateCorrelation(x, y);
      return r * r;
    }
    
    // Estimate standardized coefficient (beta)
    function estimateStandardizedCoefficient(x, y) {
      const sdX = calculateStandardDeviation(x);
      const sdY = calculateStandardDeviation(y);
      
      return calculateCorrelation(x, y) * (sdY / sdX) * (sdX / sdY);
    }
    
    // Calculate simulated effect size for ANOVA
    function calculateSimulatedEffectSize(means, grandMean) {
      if (means.length <= 1) return 0;
      
      // Calculate sum of squares between groups
      const ssBetween = means.reduce((sum, mean) => sum + Math.pow(mean - grandMean, 2), 0);
      
      // Simulate total sum of squares (very simplified)
      const ssTotal = ssBetween * (1 + Math.random() * 2);
      
      return ssBetween / ssTotal;
    }
    
    // Format p-value
    function formatPValue(p) {
      if (p < 0.001) return 'p < .001';
      return `p = ${p.toFixed(3)}`;
    }
    
    // Interpret effect size (Cohen's d)
    function interpretEffectSize(d) {
      const absD = Math.abs(d);
      
      if (absD < 0.2) return 'very small';
      if (absD < 0.5) return 'small';
      if (absD < 0.8) return 'medium';
      return 'large';
    }
    
    // Interpret eta-squared
    function interpretEtaSquared(etaSquared) {
      if (etaSquared < 0.01) return 'very small';
      if (etaSquared < 0.06) return 'small';
      if (etaSquared < 0.14) return 'medium';
      return 'large';
    }
    
    // Interpret correlation coefficient
    function interpretCorrelation(r) {
      const absR = Math.abs(r);
      
      if (absR < 0.1) return 'negligible';
      if (absR < 0.3) return 'weak';
      if (absR < 0.5) return 'moderate';
      if (absR < 0.7) return 'strong';
      return 'very strong';
    }
    
    // Get color for chart based on index
    function getColorForIndex(index, alpha = 0.7) {
      const colors = [
        `rgba(99, 102, 241, ${alpha})`,   // Indigo
        `rgba(236, 72, 153, ${alpha})`,   // Pink
        `rgba(34, 197, 94, ${alpha})`,    // Green
        `rgba(249, 115, 22, ${alpha})`,   // Orange
        `rgba(59, 130, 246, ${alpha})`,   // Blue
        `rgba(168, 85, 247, ${alpha})`,   // Purple
        `rgba(234, 179, 8, ${alpha})`,    // Yellow
        `rgba(14, 165, 233, ${alpha})`,   // Sky blue
        `rgba(239, 68, 68, ${alpha})`,    // Red
        `rgba(20, 184, 166, ${alpha})`,   // Teal
      ];
      
      return colors[index % colors.length];
    }
  </script>
<script>
function formatNumber(n, decimals = 1) {
  return Number.parseFloat(n).toFixed(decimals);
}

// Modify processExcel to add detailed upload message and data quality
const originalProcessExcel = processExcel;
processExcel = function(file) {
  const startTime = performance.now();
  const reader = new FileReader();
  
  reader.onload = function(e) {
    const data = new Uint8Array(e.target.result);
    const workbook = XLSX.read(data, { type: 'array' });
    const firstSheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[firstSheetName];
    dataTable = XLSX.utils.sheet_to_json(worksheet, { raw: false });
    columns = Object.keys(dataTable[0]);
    dataLoaded = true;
    
    // Data statistics
    const elapsed = performance.now() - startTime;
    const rowCount = dataTable.length;
    const columnCount = columns.length;
    const missingCells = dataTable.reduce((acc, row) => {
      return acc + columns.reduce((a, col) => a + (!row[col] ? 1 : 0), 0);
    }, 0);
    const totalCells = rowCount * columnCount;
    const missingRate = formatNumber(100 * missingCells / totalCells);
    
    logToConsole(`Processed Excel file with ${rowCount} rows and ${columnCount} columns`);
    showMessage('file-status', `âœ… File "${file.name}" successfully loaded and processed in ${formatNumber(elapsed / 1000, 2)}s. Found ${rowCount} rows and ${columnCount} columns.`, 'success');

    displayDataPreview();
    displayVariableList();
        if (typeof buildVariableSummaryTable === 'function') buildVariableSummaryTable();

    document.getElementById('loading-spinner').style.display = 'none';
    updateStepStatus(2, 'completed');
    updateStepStatus(3, 'active');
    document.getElementById('variable-list-card').style.display = 'block';

    // Inject Data Quality Assessment
    const previewContainer = document.getElementById('data-preview');
    const qualityHTML = `
      <div class="explanation-panel" style="border-left-color: #22c55e;">
        <h4>ðŸ§ª Data Quality Assessment</h4>
        <p><strong>High-Quality Data</strong><br>
        Your data appears to be of high quality with only ${missingRate}% missing values. Sample size (${rowCount} rows) is adequate for most statistical analyses.</p>
      </div>`;
    previewContainer.insertAdjacentHTML('beforeend', qualityHTML);
  };

  reader.onerror = function() {
    logToConsole('Error reading file', 'error');
    document.getElementById('loading-spinner').style.display = 'none';
    showMessage('file-status', 'Error reading file', 'error');
  };

  reader.readAsArrayBuffer(file);
};
</script>
<script>
// Extend variable display with interactive stats
function displayVariableList() {
  const numericalContainer = document.getElementById('numerical-variables');
  const categoricalContainer = document.getElementById('categorical-variables');
  numericalContainer.innerHTML = '';
  categoricalContainer.innerHTML = '';

  columns.forEach(column => {
    const type = inferColumnType(column);
    const values = dataTable.map(row => row[column]).filter(v => v !== null && v !== undefined && v !== '');
    const uniqueCount = new Set(values).size;

    let summary = '';
    if (type === 'Numerical') {
      const numVals = values.map(v => parseFloat(v)).filter(v => !isNaN(v));
      const mean = formatNumber(math.mean(numVals));
      const std = formatNumber(math.std(numVals));
      const min = formatNumber(Math.min(...numVals));
      const max = formatNumber(Math.max(...numVals));
      summary = `<small>Mean: ${mean}, SD: ${std}, Range: [${min}, ${max}]</small>`;
    } else {
      summary = `<small>${uniqueCount} unique categories</small>`;
    }

    const item = document.createElement('div');
    item.className = 'variable-item';
    item.innerHTML = `
      <div>
        <strong>${column}</strong><br>${summary}
      </div>
      <span class="variable-type type-${type.toLowerCase()}">${type}</span>
    `;

    if (type === 'Numerical') {
      numericalContainer.appendChild(item);
    } else {
      categoricalContainer.appendChild(item);
    }
  });

  logToConsole(`Extended variable list with statistics.`);
}
</script>
<script>
// Create filter buttons and export option
function addVariableControls() {
  const container = document.querySelector('.variable-selection-box');
  if (!container || document.getElementById('variable-controls')) return;

  const controls = document.createElement('div');
  controls.id = 'variable-controls';
  controls.style.marginBottom = '1rem';
  controls.innerHTML = `
    <button class="btn btn-outline" onclick="filterVariables('all')">All</button>
    <button class="btn btn-outline" onclick="filterVariables('Numerical')">Numerical</button>
    <button class="btn btn-outline" onclick="filterVariables('Categorical')">Categorical</button>
    <button class="btn" onclick="exportVariableSummary()">Export Summary</button>
  `;
  container.insertBefore(controls, container.firstChild);
}

// Filter variables by type
function filterVariables(type) {
  document.querySelectorAll('.variable-item').forEach(el => {
    if (type === 'all') {
      el.style.display = '';
    } else {
      el.style.display = el.querySelector('.variable-type').textContent === type ? '' : 'none';
    }
  });
}

// Export variable summaries to text
function exportVariableSummary() {
  const rows = [];
  columns.forEach(column => {
    const type = inferColumnType(column);
    const values = dataTable.map(row => row[column]).filter(v => v !== null && v !== undefined && v !== '');
    let summary = '';

    if (type === 'Numerical') {
      const numVals = values.map(v => parseFloat(v)).filter(v => !isNaN(v));
      const mean = formatNumber(math.mean(numVals));
      const std = formatNumber(math.std(numVals));
      const min = formatNumber(Math.min(...numVals));
      const max = formatNumber(Math.max(...numVals));
      summary = `Mean: ${mean}, SD: ${std}, Range: [${min}, ${max}]`;
    } else {
      summary = `${new Set(values).size} unique values`;
    }

    rows.push(`${column} (${type}): ${summary}`);
  });

  const blob = new Blob([rows.join('\n')], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'variable_summary.txt';
  a.click();
  URL.revokeObjectURL(url);
}

// Add tooltips on hover for variables
document.addEventListener('mouseover', function(e) {
  const item = e.target.closest('.variable-item');
  if (!item || item.title) return;

  const typeTag = item.querySelector('.variable-type');
  if (!typeTag) return;

  const summary = item.querySelector('small')?.innerText || '';
  item.title = summary;
});

document.addEventListener('DOMContentLoaded', function() {
  addVariableControls();
});
</script>
<script>
// Suggest variables for analysis using OpenAI
async function suggestVariablesWithAI() {
  const apiKey = document.getElementById('api-key').value;
  if (!apiKey) {
    showMessage('api-status', 'API key is required for AI analysis.', 'error');
    return;
  }

  const prompt = `You are a statistical assistant for a translation studies researcher. 
Given this dataset's variables:
${columns.join(', ')}

Suggest 2-3 meaningful hypotheses that can be tested using statistical methods. Indicate which variables to use and the type of test (e.g., t-test, correlation, ANOVA, regression).`;

  try {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: "gpt-3.5-turbo",
        messages: [{ role: "user", content: prompt }],
        temperature: 0.7
      })
    });

    const result = await response.json();
    if (result.choices && result.choices.length > 0) {
      const suggestions = result.choices[0].message.content;
      const suggestionContainer = document.createElement('div');
      suggestionContainer.className = 'explanation-panel';
      suggestionContainer.innerHTML = `<h4>ðŸ¤– Suggested Hypotheses</h4><pre style="white-space: pre-wrap;">${suggestions}</pre>`;
      document.getElementById('test-selection-card').appendChild(suggestionContainer);
    } else {
      logToConsole("AI did not return any suggestions.");
    }
  } catch (error) {
    logToConsole("AI suggestion error: " + error.message, 'error');
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const btn = document.createElement('button');
  btn.className = 'btn btn-secondary';
  btn.textContent = 'AI Suggest Hypotheses';
  btn.onclick = suggestVariablesWithAI;
  const testCard = document.getElementById('test-selection-card');
  if (testCard) {
    testCard.querySelector('.section').appendChild(btn);
  }
});
</script>
<script>
// Local File Persistence
window.addEventListener('beforeunload', () => {
  if (dataLoaded) {
    localStorage.setItem('translation_data', JSON.stringify(dataTable));
    localStorage.setItem('translation_columns', JSON.stringify(columns));
  }
});

window.addEventListener('DOMContentLoaded', () => {
  const savedData = localStorage.getItem('translation_data');
  const savedColumns = localStorage.getItem('translation_columns');
  if (savedData && savedColumns) {
    try {
      dataTable = JSON.parse(savedData);
      columns = JSON.parse(savedColumns);
      dataLoaded = true;
      displayDataPreview();
      displayVariableList();
        if (typeof buildVariableSummaryTable === 'function') buildVariableSummaryTable();
      updateStepStatus(2, 'completed');
      updateStepStatus(3, 'active');
      document.getElementById('variable-list-card').style.display = 'block';
      logToConsole("Session restored from local storage.");
    } catch (e) {
      logToConsole("Failed to restore session.", "error");
    }
  }
});

// Export Report to HTML (can be saved as PDF manually)
function exportAnalysisReport() {
  const apa = document.getElementById('apa-formatted-results').innerHTML;
  const summary = document.getElementById('results-summary').innerHTML;
  const detailed = document.getElementById('detailed-results').innerHTML;
  const html = `
    <html><head><title>Analysis Report</title><link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700;800&display=swap" rel="stylesheet">




<style>
.header {
  background: linear-gradient(to bottom, #D0D6E0, #BFC9DC);
  text-align: center;
  padding: 3rem 1rem 2rem 1rem;
}

.title {
  font-family: 'Poppins', sans-serif;
  font-size: 76px;
  font-weight: 800;
  color: #FFFFFF;
  text-align: center;
  letter-spacing: -0.3px;
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
  margin-bottom: 0.5rem;
}

.subheading {
  font-family: 'Poppins', sans-serif;
  font-size: 27px;
  font-weight: 500;
  color: #DADADA;
  text-align: center;
  max-width: 80%;
  margin: 0 auto;
  letter-spacing: 0.3px;
}
</style>


<style>
.footer {
  background-color: #5C5CFF;
  color: #F1F1F1;
  text-align: center;
  padding: 20px 0;
  font-size: 17px;
}
.footer p {
  margin: 4px 0;
}
</style>


<style>
.title {
  font-family: 'Poppins', sans-serif;
  font-size: 76px;
  font-weight: 800;
  background: linear-gradient(90deg, #5C5CFF, #00CFFD);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-align: center;
  letter-spacing: -0.3px;
  margin-bottom: 0.5rem;
  transition: transform 0.3s ease, text-shadow 0.3s ease;
  animation: fadeInUp 0.8s ease-out both;
}

.title:hover {
  transform: scale(1.03);
  text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.15);
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
</style>

</head><body>
    <h2>Summary</h2>${summary}
    <h2>APA Results</h2>${apa}
    <h2>Detailed Statistics</h2>${detailed}
    
<script>
function populateVariableSelectorsByRole(testType) {
  const getSelect = id => document.getElementById(id);

  // Clear all select boxes
  ['ind-ttest-dv', 'ind-ttest-grouping', 'paired-ttest-var1', 'paired-ttest-var2',
   'one-way-dv', 'one-way-factor', 'two-way-dv', 'two-way-factor1', 'two-way-factor2',
   'correlation-var1', 'correlation-var2', 'regression-dv', 'regression-iv'].forEach(id => {
    const el = getSelect(id);
    if (el) el.innerHTML = '';
  });

  columns.forEach(col => {
    const role = variableRoles[col];
    const opt = document.createElement('option');
    opt.value = col;
    opt.textContent = col;

    if (role === 'Dependent' || role === 'Likely Dependent') {
      ['ind-ttest-dv', 'one-way-dv', 'two-way-dv', 'correlation-var1', 'correlation-var2', 'regression-dv'].forEach(id => {
        const el = getSelect(id);
        if (el) el.appendChild(opt.cloneNode(true));
      });
    }

    if (role === 'Independent' || role === 'Independent/Covariate') {
      ['ind-ttest-grouping', 'one-way-factor', 'two-way-factor1', 'two-way-factor2', 'regression-iv'].forEach(id => {
        const el = getSelect(id);
        if (el) el.appendChild(opt.cloneNode(true));
      });
    }

    if (role === 'Random/Blocking') {
      // Optionally populate for future mixed models
    }

    // For paired tests, all DVs are fair game
    ['paired-ttest-var1', 'paired-ttest-var2'].forEach(id => {
      const el = getSelect(id);
      if (el) el.appendChild(opt.cloneNode(true));
    });
  });
}
</script>

</body></html>